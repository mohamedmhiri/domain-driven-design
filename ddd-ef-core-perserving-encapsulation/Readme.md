Course Overview

Hi everyone. My name is Vladimir Khorikov, and welcome to my course, Domain‑Driven Design and EF Core: Preserving Encapsulation. I'm very excited to share this course with you. Entity Framework has made great progress over the past several years and introduced a lot of features that help you build rich, highly encapsulated domain models. But there still are pitfalls and shortcomings that you need to be aware of. This course will show you how to preserve encapsulation of your domain models and apply domain‑driven design in applications with EF Core. You will learn various mapping techniques, and that will help you build complex domain models on one hand and leverage the full power of EF Core on the other. Some of the major topics that we will cover include mapping value objects, working with detached objects, mapping one‑to‑many relationships, and implementing a domain event dispatcher. By the end of this course, you will know everything needed to start applying domain‑driven design in your own projects with EF Core. Before beginning this course, you should be familiar with the C# programming language and Entity Framework. I hope you will join me on this journey to learn how to combine domain‑driven design and EF Core, here at Pluralsight. .
Introduction
Introduction

Hi, my name is Vladimir Khorikov, and this is the course Domain‑Driven Design and EF Core: Preserving Encapsulation. If you tried to apply domain‑driven design principles to a project using the Entity Framework in the past, you most likely had a fair share of challenges when you tried to separate your domain model from persistence concerns. The earlier versions of Entity Framework had a history of not playing nice with domain‑driven design. This screenshot shows a typical example of a model generated by one of the first versions of Entity Framework. Fortunately, this problem becomes smaller and smaller with new EF releases, and in the latest versions, the EF Core team has introduced important functionality that helps you keep your domain model clean and separated from the framework concerns. This course will show that functionality. You will learn how to use EF Core in a way that doesn't damage your domain model's encapsulation and maintains the separation of concerns between the domain model and the database. You will see a detailed step‑by‑step process of building a rich domain model using EF Core. Along the way, I will show how EF Core works internally and which of its features you should use and why. You will also learn some advanced EF Core mapping techniques and common pitfalls you should avoid. Here's a quick outline of this course. In the first module, we will talk about the principles of encapsulation and separation of concerns and why these two principles are important. I'll also introduce the sample project we'll be working on throughout this course. In the next module, we'll talk about many‑to‑one relationships. Although this topic looks quite simple, there's much more to it than meets the eye. In the module after that, we'll explore lazy loading and will introduce a base entity class. In the next module, I'll show how to use backing fields to encapsulate operations with collections of related entities. Next, you'll see how to work with value objects. There is not one, but two features in EF Core that you can use for that, value conversions and owned entity types. You will see both of them in action. Finally, in the last module, we'll discuss implementing a domain event dispatcher using EF Core. For this course, you will need a basic knowledge of domain‑driven design and Entity Framework Core. For domain‑driven design, I recommend these two of my courses, Domain‑Driven Design in Practice, and Refactoring from Anemic Domain Models. For EF Core, I recommend this course from Julie Lerman.
Encapsulation and Separation of Concerns

This course will focus on two important principles, encapsulation and separation of concerns. Although these two principles ultimately serve the same goal, they are different nonetheless. Let's talk about what they are and what goal they help you to achieve. Encapsulation is an act of protecting data integrity. A class is properly encapsulated when its internal data cannot possibly be sent to an invalid or inconsistent state. There are two techniques that help you with that, information hiding and bundling data and operations together. Information hiding helps you to remove the classes internals from the eyes of its clients, so there is less risk of corrupting those internals. Bundling of data and operations helps you to establish a single entry point for all actions that can be done upon this class. This way you can perform all required validations and integrity checks before modifying that class. You can think of encapsulation in terms of invariants. Each class has its own set of invariants, conditions that must be held true at all times. It is your responsibility as a software developer to make sure that those invariants are never violated. I have a whole course that is devoted to the topic of encapsulation and I highly recommend that you check it out, if you haven't already, Refactoring from Anemic Domain Models Towards a Rich One. The second principle we'll be focusing on is separation of concerns. The idea behind it is that each application concern should have its own place in the code base and not overlap with other concerns. The typical example, and the one we'll be talking about in this course, is the combination of ORM and domain modeling concerns. Each class in your code base should address either one or the other of these concerns, but not both. And oftentimes, it's not that easy to implement such a separation. You can think of separation of concerns as the single responsibility principle applied on a larger scale. The difference is that the single responsibility principle usually targets individual classes, whereas separation of concerns is normally applied at the architectural level. So why focus on these two principles? It's all about complexity. Uncontrollable growth of complexity is your biggest problem as a software developer. The more complex the code base becomes, the harder it is to work with and develop new functionality. Complex code bases are also more prone to bugs. The reduction of complexity is the goal that lies at the foundation of many software principles. In fact, many of my other courses target this goal, too, albeit from different angles. Here's how you can visualize code complexity and the two principles, encapsulation and separation of concerns, that help you to reduce that complexity. Complexity emerges from coupling. You can view code complexity as the number of connections between different code elements, classes, methods, class fields and so on. When all of your code elements are interconnected with each other, the complexity grows exponentially with addition off new code, because each element connects with the ever increasing number of other code elements. You can only hold so many of such connections in your mind at a time, because, unfortunately, our cognitive abilities are not very good at scaling. And so eventually, if you don't take action, the code base will become so over complicated that it will quickly dissolve into a big ball of mud, a mass that is so hard to deal with that all development essentially stops. Separation of concerns helps you to divide this big bowl of mud into smaller pieces. Note that the number of code elements stays the same, but the number of connections between them reduces significantly. That's also reducing the overall complexity. This is called decoupling. It's when you group related code elements into buckets in which those elements remain highly connected, but buckets themselves become loosely coupled. This is, by the way, the principle of high cohesion and loose coupling in action. Cohesion, also known as internal coupling, can be high inside those buckets, but coupling, which is also known as external coupling, should be low between those buckets. With such a decoupling, you can reason about separate buckets independently, which is much easier because it doesn't go beyond your cognitive capacity. This technique also allows you to reduce the rate of complexity growth. Because the size of the buckets is limited, the overall code complexity grows with the number of buckets, not with the number of code elements. In this course, we'll be talking about three of such buckets, domain modeling, ORM mappings, and the database. As for encapsulation, it also helps reduce complexity, but from a different angle. It eliminates connections inside the bucket, not between them. This is achieved by restricting the classes public API surface area, through which those classes can mutate each other's state. All right, let's take some examples of encapsulation and separation of concerns in action.
Encapsulation and Separation of Concerns: Examples

Here is a domain class, Course, that consists of two fields, IsActive and NumberOfStudents. You can also see Entity Framework's attributes that map these fields to the database columns. This code violates the principle of separation of concerns. There are two of such concerns here, domain modeling and ORM mapping, and both of them occupy the same piece of code, the Course class. This is a simple example, of course, and it might not seem like a big deal here. But in real‑world applications, such a lack of separation starts to negatively affect your code base rather quickly. Your ability to focus on domain modeling and ORM mapping concerns independently from each other is crucial for restricting the complexity growth over time and ultimately for the project's success. Because of this lack of proper separation, I recommend that you never use mapping attributes. Luckily, it's easy to avoid them in EF Core. You just need to use fluent mapping instead. Note that it's fine to violate the separation of concerns principle when one of the concerns is simple and introduces virtually no additional complexity. An example would be validation attributes in incoming DTO objects. DTOs, data transfer objects, serve as containers of data that external clients send to your application with their requests. The responsibility of being a container is very simple. It doesn't require anything other than the presence of these properties in DTO classes. And so adding another responsibility, such as input validation, doesn't lead to exponential growth of complexity. The situation with using mapping attributes on domain classes is different though. Both of these responsibilities, ORM mapping and domain modeling, are complex in and of themselves, and so you don't want to mix them together. Alright, let's also take a look at an example with encapsulation or, rather, the lack of it. Here's the Course class once again. Let's say that it has a business requirement an invariant. To reiterate, an invariant is a condition that must be held true at all times during the full lifetime of all instances of the class. So the invariant says that if the course becomes inactive, it cannot have any students, which means that whenever you set this IsActive field to false, the NumberOfStudents property should be set to zero with it. In the current implementation, there is no way for the class to impose this invariant because the clients of this class can modify these properties, however they won't without any limitations. It means that the Course class is not encapsulated. It can be brought to an inconsistent state. To fix this issue, we need to make the property setters private and introduce a separate method that would both make the course inactive and reset the number of students in it. That would be this Disable method. This version of the class maintains encapsulation by reducing its public API surface area that allows for data modification. Where previously there were two such API endpoints, the two property setters, now there is only one, the Disable method. That's what I meant when I said that encapsulation reduces complexity by eliminating connections inside a bucket. Let's go back to the drawings you saw earlier and see how this example fits in there. The domain model is the bucket here. Before the refactoring, each client of the Course class had to connect to both of the course's properties in order to disable that course. Now thanks to encapsulation, those clients have to connect to just one class member, the Disable method. Of course, decoupling is not the only benefit here. There is also the built‑in upkeep of invariants, meaning that, unlike the two property setters, it's impossible to use the Disable method in such a way that will lead to inconsistencies, which is also very important. How all this relates to EF Core you might ask. Unfortunately, the use of EF Core, and other ORMs for that matter, often requires you to compromise on encapsulation. For example, the very first versions of Entity Framework required you to have public property setters in your domain classes, which obviously was horrible for encapsulation. Thankfully, the latest versions of EF Core are much better at preserving encapsulation. There still are some edge cases you need to know about though, and that's what you are going to learn in this course. One last thing before we proceed to the sample project. People sometimes think that the principle of separation of concerns means you will never have to think about the database or the ORM again and that the only thing you need to worry about is the domain model. That's not the case. While it's true that the domain model is the most important part of your application, the ORM and the database are also important. Separation of concerns is not about disregarding EF Core or the database. It's about being able to reason about these components independently. This way, you would use the number of things you need to keep in mind simultaneously, which greatly simplifies the development process.
Sample Application Introduction

Our sample application will be a student management system. We'll start with a simple domain model, consisting of just two classes, Student and Course, and the simple relationship between them. Each student will have a reference to one favorite course. As we progress, we'll add more functionality to the domain model, for example the enrollment class that will indicate in which courses the student has enrolled in. This enrollment will contain a grade, either A, B, C, D or F. And we will add more entities to the domain model as needed to explain different concepts related to encapsulation. The source code for this course is available on GitHub. You can use this short link to access it. By the time this course goes live, this repository will contain code from all modules. You can navigate through these modules by exploring the commit history. I'll organize all commits such that you will be able to roll back changes to the start of a specific module. Just look for tags named after modules in the source control. You can also navigate to the Releases tab in the GitHub repository, which is this tab right here. This tab will show a list of tags, each containing the snapshot of the source code as it was by the start of each module. You can download that snapshot using these links here. Alright, let's now look at the code itself. Here's our sample solution. The two domain classes we have at the moment are Student and Course. Both are very simple currently. As you can see, Student consists of an ID, name, email, and the ID of the favorite course. And the Course class itself is just an ID and a name. Here's the SchoolContext, also nothing extraordinary if you've worked with EF before, a DbSet of students, courses, and their mappings. The appsettings file only has a connection string, and the Program class will play the role of application services where I will show all the typical business scenarios that require encapsulation. Right now, this class gets the ConnectionString from the config file and creates a logger. We'll use this logger to print in the console SQL statements EF Core executes behind the scenes. This filter here tells the logger to ignore any log entries other than those that contain SQL commands sent to the database. And finally, these lines build configuration options for our DbContext. In particular, they tell EF Core to use SQL Server, use the logger factory, and enable sensitive data logging. This last setting turns on the logging of SQL parameters, which is disabled by default for security reasons. Here you can see a small query. Let's run it to check out how the logging works. Here's Alice, and this is the SQL statement EF Core used to select Alice from the database. You can also write a simple update script that will add number 2 to the end of Alice's name and email. Run it, and here you can see the two SQL statements, SELECT and UPDATE. Alright, we're all set to start exploring EF Core in the context of domain‑driven design and highly encapsulated domain models.
Summary

In this model, you learned about the principles of encapsulation and separation of concerns. Both of these principles help you to reduce code complexity. Complexity stems from coupling between code elements. Separation of concerns reduces complexity by segregating those code elements into buckets and minimizing coupling between those buckets. Encapsulation reduces complexity by minimizing coupling inside the buckets. The use of ORMs, such as EF Core, puts restrictions on your domain model, which may lead to damaging encapsulation and separation of concerns. For example, earlier versions of Entity Framework required you to have public setters in your properties, which is bad for encapsulation. And the use of mapping attributes violates the separation of concerns principle. This course will help you preserve domain model encapsulation while using EF Core. In the next module, we'll start introducing encapsulation to our sample project. We'll look at many‑to‑one relationships, the use of lazy loading, and we'll introduce a base entity class.
Working with Many-to-one Relationships
Introduction

Hi, my name is Vladimir Khorikov, and this is the course Domain Driven Design and EF Core, Preserving Encapsulation. In this module, we will take a look at many‑to‑one relationships. Along the way, we will also discuss DBContext encapsulation and public property setters.
DbContext Encapsulation

Encapsulation is a property that applies to all of your code, not just domain model. As I mentioned in the previous module, to achieve proper encapsulation, you need to reduce the surface area for potential mistakes as much as possible. You do that by bundling all related functionality in one class and exposing the absolute minimum of its API. Let's take our DBContext as an example. By the way, before we start, I forgot to mention that I'm using .NET Core 3.1. As of this recording, it's in the previous stage, but the release version shouldn't have any significant changes compared to the version I'm using, only bug fixes. Also in the solution items, you can find the database script to create the database from scratch, with all the test data. I'll be adding additional scripts here when I modify the database. All right, having that out of the way, let's take a look at the DBContext, particularly this optionsBuilder here. We used this builder to create options that we then pass to the SchoolContext. Is the DBContext properly encapsulated? It is not. The problem here is once again too large of an API surface area. Our DBContext allows us to configure too many things. Does it really make sense that we can omit this UseSqlServer line or replace it with something like UseMySql? Of course not. The configuration should be restricted to things that change depending on the environment, for example, the connectionString, because the development database instance is different from the production one. But you're not goign to use SQL Server in development and MySQL in production. So the ability to configure the database vendor is excessive here. It allows you to bring the DBContext into an invalid state. But even with the options that do change depending on the environment, you need to make sure you apply them consistently. For example, these two options must be included or excluded together. It doesn't make sense to enable sensitive data logging without a logger. And so these two lines are prone to inconsistencies as well. In fact, the optionsBuilder as a whole, used outside of the DBContext class, is a giant hole in encapsulation. To maintain proper encapsulation, we need to move all this code inside the DBContext and expose the absolute minimum of configuration options. As I said, only those options that change depending on the environment. Fortunately, injection of configuration options into the DBContext is not the only way to configure it. What we can also do is override this onConfiguring method and paste all this code in there. We also don't need to create LoggerFactory method here. We can keep it in the DBContext instead. Now, instead of accepting the DBContext options in the constructor, we can accept parameters that are specific to our application, the things that change from one environment to another. That would be the connection string and whether or not we should use a console logger. Removing the call to the base class, and saving both of these parameters to private fields. Making them read‑only, just in case. It's a good idea to make all of your fields read‑only by default. I also want to inline the CreateLoggerFactory method. There's not much sense in having it as a separate method. The optionsBuilder is now passed as a parameter, so I don't need to create it anymore. Use the connectionString field here, and for these two lines, we need to either include or exclude them, depending on the UseConsoleLogger field. So if UseConsoleLogger, then use the LoggerFactory and EnableSensitiveDataLogging, and, of course, this shouldn't be a string, it should be a boolean instead. Good. Now in the program file, instead of passing in options as a parameter, we need to specify the connection string and whether or not we want to enable the logger. Note that in the real world application you want to set the second parameter to true if this is a development environment, and to false for the production one. In an ASP.NET Core application, this can be done using the IHostingEnvironment interface. Let's run our application and make sure we didn't break anything. And as you can see, everything is fine. Both the select and update SQL statements are in place. A couple of words about dependency injection. When working with ASP.NET Core, you have this very handy extension method that allows you to register the DBContext as a dependency, which you can then use in controllers. Unfortunately, it doesn't have overloads for custom DBContext instantiation. It requires your DBContext to have a constructor that accepts the optionsBuilder class. To use our custom constructor, you'll need to switch from the AddDBContext extension method to the regular AddScoped one. This extension method accepts a delegate as a factory method, where you can instantiate the DBContext however you like. The end result of both of these extension methods is the same. The DBContext gets registered as it's code dependency, meaning that it is created once per each web request and gets disposed of when that request is completed. All right, let me remove all this and hard code true as the second parameter. We don't need the variable here.
Recap: DbContext Encapsulation

In the previous demo, we encapsulated the DbContext. The initial version accepted the optionsBuilder, which provided too wide of an API surface area. You can essentially do anything with these options. For example, make it work with MySQL instead of SQL Server even though MySQL isn't supported. All these options should be hidden from the client code. The DbContext must expose only those configuration options that change depending on the environment. And it must do that in a way that maintains consistency. And that's exactly what we did. Instead of the optionsBuilder class, the DbContext now accepts only the connectionString and the flag that tells it to enable console logging. There is no way for us now to omit the UseSqlServer option or replace it with something like UseMySql. There's also no way for us to enable sensitive data logging without enabling a console logger. This flag here either enables both of these options or none of them. Remember how in the first module we discussed that encapsulation is an act of protecting data integrity and that it allows us to reduce code complexity by minimizing the class's public API surface area. You can see both of these effects in action here. The new version of the DbContext now doesn't accept arbitrary configuration options and thus both maintains integrity and minimizes the number of things you need to think about when using that context. By the way, this issue with overconfiguration applies to any infrastructure with rich configuration capabilities. Just because you can doesn't mean you should expose all those capabilities to the client code. Keep the configuration surface as small as possible. Of course, this advice applies only to enterprise‑level application development, not library development.
Getting Rid of Public Setters

Let's now take a look at the domain model, specifically the Student class. Public setters in domain classes is a red flag. As we discussed in the previous module, such setters prevent the class from maintaining invariants because this class has no control over how its clients use those setters. Remember to always make property setters in domain classes private by default. You can make them public later if needed, but the default configuration should always be a public getter and the private setter. So let me do exactly that. There are some compilation errors, so I'm removing this code for now. Let's run the application and see if it still works. Everything is good as you can see. EF Core has loaded Alice just as before. EF Core can do that because it binds to properties backing fields by default. So it actually doesn't even care if you have any property setters. If you wonder what backing fields I'm talking about, C# actually generates those for each of such properties behind the scenes. EF Core uses reflection to find those backing fields and assign values to them. There is currently no constructor in the Student class, and that means C# will generate a default public constructor with no parameters for us. With that constructor, we can instantiate a student like this. In the vast majority of cases though, this is not how you want to instantiate your domain classes because those classes almost always have mandatory fields. For example, in our domain model, all three of these fields are mandatory in students. You cannot create a student without specifying their name, email, and the favorite course. The presence of a public parameterless constructor goes around this requirement and may bring the student into an invalid state. Remember your domain classes should always reside in a valid state right from the time you instantiate them. There should be no such things as temporary or transitory states where you allow the object to remain invalid. Each public method on the domain class should maintain that class's invariants. And, of course, the constructor is one of those public methods. So to maintain proper encapsulation, we need to explicitly define a constructor that will accept all the fields that are mandatory for the students. In our case, it's Name, Email, and the FavoriteCourseId. The addition of an explicit constructor will make the C# compiler not generate the public parameterless constructor anymore, which is exactly what we need. In older versions of Entity Framework, you had to keep that parameterless constructor so that Entity Framework could instantiate the class. In the current version of EF Core, you don't need to do that anymore. Entity Framework can now use your custom constructor to instantiate objects of that class. As you can see when I run the application, the student is loaded just as before. The way it works is EF Core matches constructor arguments to properties by their names and supplies the corresponding values to them. Here you can see EF was able to supply all three input parameters because they have the same names as the corresponding properties. If you modify the name of a parameter, let's say put number 2 here, then you will get an exception saying that Entity Framework couldn't find a value for that parameter. Let me change it back. And also Entity Framework allows you to define not all of the classes properties, but just a subset of them. Here you can see a name and email are still supplied. And if I go back to the program file, you can see that the FavoriteCourseId is still here even though we didn't request it in the constructor. The same is true for the student ID, which means that Entity Framework supplied these two values separately from the constructor. Note that Entity Framework makes the assumption that you assigned constructor arguments to properties yourself. If you define an argument in the constructor, EF Core will supply it, but it will not attach the property after that. So if I don't initialize the Name property and run the application, you can see that this name will remain empty. Alright, let me change that and bring back the FavoriteCourseId as an argument. Good. You can go even further and remove setters altogether. As I mentioned earlier, EF Core binds to backing fields by default, and so it doesn't need property setters. But because student is an entity and not a value object, you will probably need to change those properties at some point, and so it's better to keep private setters. We will talk about value objects later in this course.
Recap: Getting Rid of Public Setters

With public property setters, your domain classes cannot maintain their invariants. In the previous demo, we have made property setters in the Student class private. Always start as small as possible with regards to class members that allow for data modification. Introduce those members gradually as you uncover new business requirements. Don't add such members up front. Postpone introducing them to as late a stage of your project as possible. We also introduced the class constructor that accepts all fields required to create a student. Never allow your domain classes to reside in an invalid state. All class members, including constructors, should maintain the classes invariants at all times. The requirement to always have a name, email, and a favorite course is one off such invariants. We, of course, still have some problems with custom constructors, though, And so in most cases you'll have to keep the parameterless constructor anyway. We'll discuss it later in this model.
Types of Relationships

Before we start discussing many‑to‑one relationships, which is the title of this module, let's make an overview of all types of relationships. There are four of such types. One‑to‑one, one‑to‑many, many‑to‑one, and many‑to‑many relationships. This naming stems from relational databases, where you have tables that relate to each other in different ways. For example, if we have two tables, Student and StudentDetails, they would be related as one‑to‑one, which means that for each student row there can be only one corresponding row in the StudentDetails table. And also for StudentDetails, there can be only one student, meaning that one StudentDetails cannot belong to more than one student. This is what this notion of one‑to‑one describes. The first word describes how many StudentDetails a student can have, and the second word describes how many students one StudentDetail may have. The answer to both is one. At the database level, you can create a one‑to‑one relationship by creating a foreign key constraint from StudentDetailsID to StudentID. At the domain model level, one‑to‑one relationships are represented with the reference to the related entity. If we had an enrollment table in our database, the relationship between students and enrollments would be one‑to‑many, meaning that a student can have many enrollments, but an enrollment can have only one student. At the domain model level, one‑to‑many relationships are represented with collections. The inverse of one‑to‑many is a many‑to‑one relationship. This is the relationship between enrollments and students, but is also the relationship between students and favorite courses. At the domain model level, these are represented with references just like one‑to‑one relationships. Finally, many‑to‑many relationships would be between students and instructors. Each student may have many instructors, but each instructor can also have many students. In the database, you can create a many‑to‑many relationship by stacking two one‑to‑many relationships. You can do that using an intermediate table, like student to instructor. Both students and instructors would have a one‑to‑many relationship with that table. At the domain model level, these relationships are presented by collections on both sides of the relation. Each instructor has a collection of students, and each student has a collection of instructors. We'll discuss all of these relationships in this course, starting with the many‑to‑one relationship. By the way, you don't have to reflect all of these relationships in your domain model. In fact, the fewer relationships you have in your domain classes, the lower is the coupling between classes and the simpler your domain model becomes, as a result. And you can see, for example, that in our database we already have a many‑to‑one relationship between students and favorite courses. And by extension, we also have a one‑to‑many relationship between courses and students, because in relational databases, relationships go in symmetrical pairs. So despite having two relationships in the database, in our domain model, we only have one of them, the many‑to‑one relationship from students to courses, which is the FavoriteCourseID property. There is no inverse relationship, which would take form of a collection of students in the course class. All this tries to reduce the number of relationships in your domain model to the absolute minimum in order to minimize code complexity.
Many-to-one Relationships: IDs vs. Navigation Properties

There are two ways to represent a many‑to‑one relationship, such as the relationship between students and their favorite courses. One is to create an ID pointing to the student's favorite course. This is how the Student class currently implements this relationship with the FavoriteCourseId property. The other way is to use the Navigation property, like this. To build a rich and encapsulated domain model, always prefer navigation properties over IDs when working with many‑to‑one relationships. The reason why is because the use of IDs in the domain model violates the separation of concerns principle. Look at it this way, to see how well your domain model is separated from the ORM and the database concerns, you need to imagine how you would design your domain model if persistence of your domain objects in the database was not an issue, meaning that if you will not have to save them to and retrieve them from the database, and all your domain model could fit in‑memory. In this imaginary ideal world, you wouldn't have to represent the student's favorite course with an ID; you will just have a direct reference to that course and navigation property. The only reason why you have those IDs is because you need to persist the relationship between students and their favorite courses in the database, which, of course, violates the principle of separation of concerns because your domain model is now impacted by how it is stored in the database. The separation of concerns between the domain model and the database is also called persistence ignorance, which means that the domain model must not know how it is persisted in the data storage. Of course, it's not always possible to achieve full persistence ignorance in your domain model, and you will almost always have to make concessions. Still, strive to achieve as much of it as possible. Fortunately, it's easy to avoid such a violation in the case of many‑to‑one relationships. You just need to use navigation properties in place of foreign key IDs. Entity Framework will create shadow properties for those IDs, but your domain model will be unaffected by them. Those IDs will be an implementation detail specific to how EF Core keeps track of your domain model. All right, I need to make some side notes here because I'm sure you have a lot of questions about the use of IDs. First of all, there are the notions of surrogate IDs and natural IDs. Surrogate IDs are IDs generated by the database for the specific purpose of being a unique identifier for some role in a particular database table. For example, the student ID and the course ID in our domain model are generated by the database, which makes them surrogate IDs. A natural ID, on the other hand, is some property of a domain object that uniquely identifies that object among others. For example, a student email is a natural ID for the student entity because each student should have their own unique email address. So, having that said, only the use of surrogate IDs in the domain model violates the separation of concerns principle. Of course, the use of email addresses in the domain model doesn't violate anything because the notion of the email address belongs to the domain layer. Second, the use of entity's own ID doesn't go against the principle of separation of concerns. Each entity has an inherent intangible identity, and the student ID generated by the database is a good approximation for that identity. A student always has knowledge about its own identity, and so this ID here is fine, but the student shouldn't deal with identities of other objects, only with those objects themselves, such as the favorite course object. And finally, the third side note is that this discussion about separation of concerns between the domain model and the database only applies to the innermost layer in the onion architecture, the domain model itself, which consists of entities, value objects, and pure domain services. This is the layer that is responsible for domain modeling and should be separated from all other concerns, including persistence concerns. The outer layer, which is the application services layer, is responsible for coordinating the domain and persistence concerns, and thus can and should work with entity's IDs. It is not persistence ignorant. This coordination usually works as follows. A controller which belongs to the application services layer uses a student ID and a course ID to retrieve the student and the course from the database, delegates the work to the domain model, and then persists the results back to the database. Note that it's perfectly fine for the controller to refer to student and course IDs, because, again, the principle of persistence ignorance doesn't apply to the application services layer. But once the execution enters the domain layer in step two, that domain layer should no longer work with those IDs, only with the domain objects themselves. All right, let's refactor our domain model according to this guideline.
Refactoring to Navigation Properties

Instead of the FavoriteCourseId property, we need to introduce a navigation property, FavouriteCourse, and the delete the ID, modifying the constructor to accept course instance instead of an ID. Good. To map the navigation property we need to use this HasOne method and combine it with this WithMany method. This is how you set up many‑to‑one relationships in Entity Framework. If you want to reflect to the other side of this relationship in the domain model as well, you need to indicate a collection of students in the course class using this WithMany method. In our domain model courses don't have a collection of students, though, so I'm leaving this method empty. Let's go to our Program class and try to run the application. As you can see, EF Core throws an exception, saying that it cannot find a suitable constructor in the Student class. That's because we modified to this class's constructor to accept the the FavoriteCourse itself instead of its ID. That's what I meant when I said that you will have to keep the parameterless constructor earlier in this module. Entity Framework is smart enough to supply constructor arguments if those arguments are primitive types, but not smart enough to do the same for navigation properties. To fix this, we need to introduce a parameterless constructor. This constructor doesn't have to be public, so it doesn't violate the class's encapsulation, but it does violate the separation of concerns principle because now our Student class is different from the version we would have ended up with if we didn't have to deal with the ORM. It's a minor violation though, and so I wouldn't worry about it too much. This is one of the concessions you have to make when working with our ORMs. I am making the public constructor call the private one so that ReSharper doesn't complain that no one used that private constructor. You don't have to do that, of course. Let's run the application again. As you can see, the addition of private parameterless constructor fixed the exception. Entity Framework has loaded the student itself, but not the FavoriteCourse. That's because by default, Entity Framework doesn't load any navigation properties. To make it work, we need to include the FavoriteCourse explicitly and call SingleorDefault with the student Id. Let's run it once again, and you can see that now all properties are loaded into memory, including Alice's FavoriteCourse, chemistry. We will talk more about issues related to eager loading of navigation properties in the next module.
Recap: Refactoring to Navigation Properties

In the previous demo, we refactored the student's favorite course from an ID to a navigation property. This relationship between students and their favorite courses now doesn't violate the principle of separation of concerns. We also had to introduce the private parameterless constructor. And let me reiterate what we discussed earlier about the use of IDs. Always use navigation properties instead of IDs in the domain model. Note that this guideline only applies to IDs of related entities, not the entity's own ID. Also, this guideline only applies to the domain model, entities, value objects, and pure domain services, not the application services layer. You don't need to keep the application services layer separated from persistence concerns, and so it's fine to use IDs in there.
Summary

In this module, you learned how to encapsulate a DbContext. Expose as low a configuration surface as possible with your DbContext. Only allow to configure things that change depending on the environment, such as the connection string and whether or not to enable console logging. Make all property setters in your domain model private by default. Public setters are a huge red flag that indicates that the domain model is not properly encapsulated. Always start as small as possible with regards to class members. That allows for data modification. Introduce those members gradually as you uncover new business requirements. Don't add such members up front. Postpone introducing them to as late of stage of your project as possible. We talked about types of relationships in the database and in the domain model. There are four such types: one‑to‑one, one‑to‑many, many‑to‑one, and many‑to‑many relationships. Keep as few of such relationships as possible in your domain model. For example, we have the many‑to‑one relationship from students to their favorite courses. But in the Course class, we don't have a list of students who chose this course as their favorite one. Always use navigation properties instead of IDs in the domain model. Surrogate IDs used for many‑to‑one relationships violate the separation of concerns principle. The only reason why you have those IDs is because you need to persist the relationship between students and their favorite courses in the database, which means your domain model is now impacted by how it is stored in the database. In the next module, we will dig deeper into eager loading of related entities. We will talk about lazy loading, and we will also introduce a base entity class.
Working with Lazy Loading
Introduction

Hi, my name is Vladimir Khorikov, and this is the course, Domain‑Driven Design and EF Core: Preserving Encapsulation. In this module, we will take a look at lazy loading, and we will introduce a base entity clause.
Eager Loading of Relationships

One common anti‑pattern that you need to avoid is partially initialized entities. Let me illustrate this anti‑pattern with an example. As I showed in the previous module, Entity Framework doesn't load related entities by default. Let me just show it once again that if I come into the Include statement and run application, the FavoriteCourse property will be set to null. The Student here is a partially initialized entity. Even though the student has a FavoriteCourse, that course wouldn't show up in the domain model. Partially initialized entities may look like a good idea at first. After all, they help you to improve application performance by not loading unnecessary data from the database. But partial initialized entities often lead to subtle bugs and growth of code complexity. Those bugs take place when you have business logic that ties to the existence of the related entity. For example, let's say that students can start a new project involving their favorite course, and so to do that, we need to add a new method, StartProject, where we check if the Student has a FavoriteCourse. And if there is no FavoriteCourse, this method doesn't do anything; otherwise, we start the project related to the favorite course. Because this method relies on the existence of the FavoriteCourse, if we don't load that course, the method will choose the incorrect code path, which will be a bug. Partially initialized entities also lead to the violation of domain model invariance, resulting in data inconsistencies, or in other words, data corruption. Even worse, the corrupted data can be persisted in the database where it would be much harder to deal with. Let me show you an example. Let's say that the Student class has a collection of Enrollments. I'm not going to created this Enrollment class. It's just for illustration purposes for now. Let's also say that our domain model has an invariant, students cannot have more than five enrollments. And so when we add a new Enrollment, we must check how many enrollments there are in the Student already and throw an exception if the number of e rollments is already five or more. If the Student already has five enrollments and we don't load them from the database, this check here will always pass. The method will add another enrollment, and we'll save that enrollment to the database in violation of the invariant. And so always load all relationships from the database, along with the entity itself. In our previous example, it's both the FavoriteCourse and the collection of enrollments. Alright, but what if you load, not all relationships, but only those that are required for the particular business scenario at hand. For example, if we are starting a new project, we don't want to add a new enrollment within the same business transaction. And so wouldn't it make sense to load only the FavoriteCourse, but not student Enrollments for that transaction? And similarly, when the business scenario is the addition of a new enrollment, wouldn't it be better to load only the enrollments and leave the FavoriteCourse empty? No, it wouldn't. When you juggle the relationships this way, you introduce additional complexity because you have to think, not only about the business scenario itself, but also about whether or not all the required data is loaded for that scenario, which increases the chances of bugs and data corruption. As a general rule, take any opportunity to avoid unnecessary complexity. In the above example, it means always loading all entity's relationships along with that entity itself. This approach is called eager loading.
Lazy Loading of Relationships

An alternative to eager loading of relationships is lazy loading. Lazy loading means that the related entity, or a collection of related entities, is not retrieved from the database unless your code refers to that entity or collection of entities. I recommend that you enable lazy loading by default because it provides simplicity gains compared to eager loading. Just like eager loading, lazy loading helps you to avoid the partially initialized entities anti‑pattern. Even though the relationships are not loaded simultaneously with the entity itself, they get retrieved from the database at the time the entity refers to those relationships so there are no invariant violations. At the same time, since you normally don't need all the relationships in each business scenario, lazy loading often turns out to be better for performance because you end up retrieving less data from the database. Note that performance comparison is not as clear cut because eager loading retrieves all data in one database round trip, while laser loading requires additional calls to the database. The main benefit here is simplicity. With lazy loading, you don't need to worry about retrieving related data explicitly using include statements. You may sometimes hear people criticize lazy loading, saying that it leads to the N+1 problem. The N+1 problem is when you first load the entity itself and then make a separate database round trip to load each of its related entities until you traverse of the full object graph. This often takes place when you want to display that entity on the UI. The N+1 problem is obviously terrible for performance. For a given page view, there should be only one database with round trip, not N+1. This is a valid criticism, but it misses an important factor. This problem only takes place in the read part of the application. It's true that lazy loading is harmful in reads, but it is beneficial in writes because of the simplicity gains I mentioned earlier, and because in writes you rarely need to load the whole entity unless this entity is very simple. The solution here is not to disable lazy loading altogether, but to adhere to the CQRS pattern and only use lazy loading in writes, not reads. In fact, you don't need a domain model or a fully fledged ORM such as Entity Framework in reads at all. One of the main goals of domain modeling is encapsulation, and, as you might remember from the first module, encapsulation is about preserving data consistency, in light of any changes. The lack of data changes makes encapsulation of reads pointless. In reads, it's better to use plain SQL with basic ADO.NET, or a micro ORM, such as Dapper. This will give you better performance because you will be able to bypass unnecessary layers of abstraction. Check out my course, CQRS in Practice for more information about the CQRS pattern.
Refactoring to Lazy Loading

Let's now introduce lazy loading in our sample project. Before we do that, let me remove all this, this collection, and this method call here. Alright to enable lazy loading, first you need to install this nuget package called Microsoft.EntityFrameworkCore.Proxies. And second in the SchoolContext, you need to add this UseLazyLoadingProxies line. Lazy loading puts some restrictions on your domain model. In particular, it requires that all your navigation properties are declared as virtual and that all domain classes are not sealed and have a non‑private parameterless constructor. The Student class isn't sealed, so I don't need to change that part. But I do need to make our private constructor protected. Overall, there are no changes in encapsulation because from an encapsulation standpoint, protected constructors are the same as private ones. But this virtual keyword is once again a dent in the persistence ignorance. It's another concession you have to make in order to use EF Core. But just like the private constructor, it's a small one, so I wouldn't worry about it. The reason why we have to declare all navigation properties as virtual is because EF Core overwrites these properties in the proxy class, such that the underlying data is retrieved from the database the first time you access those properties. This is how ORMs in general and EF Core in particular implement lazy loading. They intercept your calls to navigation properties and only then materialize them from the database. Note that the presence of runtime proxies doesn't go against the principle of persistence ignorance because all this complexity stays outside of your domain model. The only effect that these proxies have on the domain model are virtual navigation properties and protected parameterless constructors. Let me demonstrate how lazy loading works in practice. Our console logger doesn't show database calls originated by lazy loading, and so I have to use SQL Server Profiler here. Here you can see Visual Studio hits this breakpoint, and the SQL Server Profiler shows one SQL query that retrieves the student from the database. The FavoriteCourse isn't loaded at this point. The course gets loaded only when I expand the Student object because Visual Studio reaches out to every property in that object, including the FavoriteCourse. Here you can see the corresponding query that loads Alice's favorite course.
Recap: Refactoring to Lazy Loading

In the previous demo, we transitioned from eager loading to lazy loading of related entities. Always retrieve the object with all its dependences, either eagerly, using include statements, or lazily. This will help you avoid the partially initialized entities anti‑pattern. Prefer lazy loading over eager loading by default. It helps you reduce code complexity because you don't need the load navigation properties explicitly, EF Core does it for you on the first call to those navigation properties. Only use eager loading when it provides significant performance improvements for your particular business scenario. To enable lazy loading, you need to install this NuGet package, and also modify the domain model. Make the domain classes non‑sealed, include a protected parameter‑less constructor, and declare all navigation properties as virtual. Note that these three points go against the principle of separation of concerns, but these are acceptable concessions. The common criticism of lazy loading is that it leads to the N+1 problem, where we have to make one database call to retrieve the object itself, and then another one for each of its end relationships. This criticism is only valid for read scenarios though, to address this problem, adhere to the CQRS pattern, and separate reads from writes. Don't use EF Core or the domain model in reads, only in writes. Check out my course, CQRS in Practice, for more details. Note that there is a way to implement lazy loading without runtime proxies. If you declare a constructor that accepts an ILazyLoader, EF Core will inject that lazy loader into the domain class. You can then use it to manually load the relationship into the bank in a field. This option is terrible. It is a glaring violation of the separation between domain modeling and ORM concerns, much worse than the addition of virtual keywords, or protected parameter‑less constructors. Now your domain class is not only responsible for the domain logic, but it also takes on one of the ORM's responsibilities. Avoid the use of explicit lazy loaders.
The Identity Map Pattern

The DBContext class from EF Core implements the Identity Map Pattern. The identity map is a cache of all objects that have been read from the database within a single business transaction. When you ask a DBContext to load a student, EF Core first looks it up in the local cache, and only if it's not there, tries to retrieve it from the database. One obvious benefit of the identity map pattern is performance. Domain objects are read from the database only once, no matter how many times you ask the DBContext to load them. Another less obvious benefit this pattern provides is referential equality. We'll talk about referential equality a bit later. For now, let's review the caching functionality. Here you can see the student with ID 1 is already loaded from the database. The student's favorite course is chemistry with ID 2, which I am loading in a separate request. This letter l here means that I want the number 2 to be a long, not an integer, because student ID's in our database are represented with longs. And if I pass an integer to the find method, EF Core will throw an exception. And also I'll ask Entity framework to find student with ID 1 again. Let's start the Profiler and run the application. Here you can see Alice with her favorite course, chemistry, are successfully retrieved from the database. And if we look at the SQL Profiler, we can see just two select queries, one for Alice herself and the other one for her favorite course. Both the student and the course have been loaded from the database only once. When it requested Alice the second time, the DBContext served her data from the local cache, and indeed the same for the chemistry course. EF Core looks up not only the entity itself, but it's related data in the local cache as well. Note that the cache only works within the DBContext instance, which is fine because in most applications you will have only one DBContext per business transaction anyway. Also notice that I used the find method and not single or default to retrieve the student the second time. The difference between them is that the single or default extension method does populate the local cache of the DBContext with the data it reads from the database, but it doesn't look up for the data. In other words, it writes to the cache, but doesn't read from it. The find method, on the other hand, does both. So if I change it the second method from Find to SingleOrDefault, you can see that we now select the student two times. This is true for all LINQ extension methods, such a Single, SingleOrDefault, First, or FirstOrDefault. Neither of them read data from the DBContext cache. And so when retrieving a single entity, always use the Find method. Only use the LINQ extension methods when you need to retrieve more than one entity at once.
The Identity Map Pattern: Referential Equality

The other benefit of the identity map pattern is referential equality within a DbContext, meaning that if you request the same object from the DbContext twice, it will not create the second object with the same data, and instead will return you the same exact object in memory. Let me demonstrate it with an example. Let me change the second student retrieval back, good. To check that two references point to the same object in memory, you can use this ReferenceEquals static method in the object class. We will also check if the students FavoriteCourse points to the same course we've loaded in this line. Run the application, and you can see that both pairs point to the same object in memory, meaning that they are referentially equal. So basically, this line of code here is equivalent to assigning the first student reference to another variable, like this. The DbContext does it the same internally. It finds the corresponding student reference for the ID you provide in the Find method. Again, this takes place only within a single DbContext. If you request the same student from two DbContexts, you will get two different objects. So to reiterate, the identity map is a cache of all objects wrapped within a single business transaction. It provides two benefits, performance improvements and referential equality. To get these benefits, always prefer the Find method and not LINQ extension methods such as Single or First when loading a single entity. Only use LINQ extension methods when reading more than one entity from the database.
Encapsulating Equality Comparison

When it comes to the domain modeling, one of the most important operations is equality comparison, that is, checking if two or more domain objects are equal to each other; and as you saw in the previous demos, Entity Framework introduces additional layers of complexity when it comes to equality comparison because of the identity in my pattern. There are several ways to compare objects to each other in .NET, and it's important that all of them are consistent in terms of their results. The first way is to use the ReferenceEquals static method, just as we did in the previous demo. As you remember, this method compares two objects by reference, and returns true when the two references point to the same object in memory; and the second approach is to use the equality operator. This operator translates into another static method call. .NET provides a default implementation of that method for each class, and that default implementation is a call to the ReferenceEquals method. So, if you don't introduce any custom equality comparison, the first and the second approaches provide the exact same result. The third way is to use the equals method. Its default implementation is similar to the static ReferenceEquals method, but not exactly the same because equals is an instance method, not a static one. Finally, the fourth approach is to compare entities by their IDs. You may see people using different approaches to call it to comparison in a typical application; when it comes to the main entities, comparison by ID is probably the most popular one, but it is also incorrect. As we discussed in the previous module, domain objects should not work with IDs of other objects. This is a violation of the separation of concerns principle, but it's not the only reason why you shouldn't use IDs to compare the main objects. The second reason is that equality comparison is an operation that should be abstracted away from the client code. How exactly an entity compares itself to other entities is an implementation detail specific to that entity. The only thing the client code should be responsible for is asking the entity a question. That question is, are you the same as this other entity? It is a responsibility of the entity itself to decide how to answer that question, and so the only valid approach to equality comparison is to always use the equality operator from the client code. All the hard lifting should be encapsulated into that equality operator. Fortunately, the logic of equality comparison is the same for all entity classes, and so we can reuse it. To do that, we need to introduce a Base Entity Class.
Introducing a Base Entity Class

So I'm adding a new class called Entity and copying the implementation. If you watched my previous courses, you might remember this class from my Domain‑Driven Design in Practice course. In that course, I used the NHibernate ORM. So here I'll make some small changes for Entity Framework. You will see those changes shortly. Let's first go through this implementation. The Equals method is one of the methods provided by the .NET Framework out of the box, and it's one of the methods you need to override to make equality comparison consistent. You can pass any object into this method, and so you need to implement a bunch of validations here. If the object is null or not an entity role, then it's obviously not the same as our entity. This if statement here incorporates both of these checks. If the other entity points to the same object in memory, then we return true. No other validations are needed. If not, we make sure that its type is the same and then compare the IDs. Note that if any of the two objects are new, meaning that they are not persisted into the database yet, we cannot say if they are the same because they don't have IDs yet. Such objects are called transient objects. Here we check if any of the two objects are transient, and if so, return false. This is the equality operator, which allows you to compare two entities like this. The comparison logic here is mostly the same. But because it's a static method and not an instance one, we also need to add checks for null for both objects. Finally, we are overriding the GetHashCode method as well. Some people also add an implementation of the IEquatable interface, but this is unnecessary. IEquatable is only needed to avoid boxing and unboxing of .NET structs, which is often bad for performance. But because our base class is not a struct, it's a class, we can skip implementing that interface. The Id property here doesn't have a setter because it doesn't need it. As I mentioned earlier, Entity Framework binds directly to backing fields by default. The type of this property is long because all entities in our domain model have IDs of the same type. You could also introduce a type parameter for the type of the ID. But I recommend that you do that only if you have IDs of different types in your domain model. No need to overcomplicate things prematurely. Now that we have the base class, we can inherit student from it and remove the Id property and do the same with the Course class. Let me also remove the setter. Alright, I will run the application to make sure everything works. But before I do that, let me delete all of that and only leave the Student object here. Good. As you can see, our refactoring worked. The ID, which is now located in the base entity class, is successfully populated by Entity Framework. Let's also check the equality comparison. I'm saving the student's favorite course into a variable and retrieving this same course from the database once again. That course is chemistry with ID 2. I'm using the equality operator to compare the courses, running it, and you can see that the result is true, meaning that Alice's favorite course and the course we just retrieved from the DbContext are deemed to be same as they should. There is an issue with our current implementation though. Because Entity Framework wraps our domain objects into proxies, their type at runtime would be the type of that proxy, not the type of the domain object itself. It works fine within a DbContext because all objects materialized from the database are of the same type. But if you compare this course to a course created outside of the DbContext, that would be a problem. A common scenario here is the enumeration pattern where you have some reference data inside the database and want to reflect the same set of data in the domain model. Reference data is different from regular data in that it cannot be changed by your application. You should only modify it using database migrations. Refer to my course Database Delivery Best Practices to learn more about this topic. Let's say that in our sample project, courses are reference data, meaning that the set of available courses doesn't change often. And when it does, it also requires a new release of our software. In this case, you can apply the enumeration pattern to list all the courses in the code explicitly. To do that, you need to define them as static fields for which you specify the same data as in the database. This is the chemistry course, and we also have calculus with ID to 1. The idea here is that these two static fields should be the only way for the client code to get a course instance, which eliminates a whole set of potential issues where you, for example, create a course with an invalid name. I'll need two constructors here, this one for EF Core and the other one for the static fields. To make the second constructor work, I need to define a constructor in the Entity base class and another one for Entity Framework as well. I'm using that new constructor here to pass the ID. And, of course, this constructor should be private so that the client code couldn't create new courses. That's the whole point of the enumeration pattern. Let's go back to the program file. Now I can demonstrate the issue with the Entity base class. If I compare the course instantiated by Entity Framework to the course that is part of the enumeration, you can see that the comparison returns false even though it's the exact same course. That's because Entity Framework creates a runtime proxy on top of the first course. But the second course is just a plain object with no proxy on top of it. Let's step into the Equals method to see what's happening. The first check passes successfully because both instances inherit from Entity. But this check doesn't pass, resulting in incorrect comparison. To fix this issue, we need to introduce another method that would see if the object's type is a proxy and, if it is, return a real type. So getting the current type and the event type resides in the Castle.Proxies namespace, then use the BaseType, which is the actual type of our domain object and return it, using this new method in place of GetType and here as well. Alright, let's run the application again. And you can see that the second comparison now also returns true even though the first course is a proxy and the second one is not. Very good. And let me fix something real quick. These static fields should, of course, be read‑only so that the client code cannot assign them new values. Good
Recap: Introducing a Base Entity Class

Equality comparison is an important functionality that should be encapsulated away from the clients of your entity classes. All such clients should do to compare two instances of some entity is use the equality operator. That operator should do all the hard lifting behind the scenes, which includes checking for nulls, reference comparison, checking for instances types, and comparison by Id. That's exactly what we did when we introduced the EntityBase class. This class contains the equality comparison logic for all entities in our domain model. Because Entity Framework creates runtime proxies on top of domain classes when you enable lazy loading, we also have to modify the way we check for the object type. If that type is a proxy, we use of the underlying type this proxy wraps. Note that this method is yet another violation of the separation of concerns principle because now our BaseEntity class contains knowledge of the ORM proxy types. But just as with the other concessions, this one isn't huge, and in my opinion, is worth making.
Summary

In this module, you learned about the partially initialized entities anti‑pattern. Don't allow your entities to be partially initialized because it may lead to code overcomplication at best and to invariant violations at worst. Both eager and lazy loading allows you to avoid partially initialized entities. Try to use lazy loading by default because it helps offload the complexity of working with relationships. Use eager loading only when it provides significant performance improvements for your particular business scenarios. The common criticism of lazy loading is that it leads to the N+1 problem where we have to make one database call to retrieve the object itself and then another one for each of its end relationships. This criticism is only valid for read scenarios. To address this problem, adhere to the CQRS pattern and separate reads from writes. Don't use EF Core or the domain model in reads. Use them only in writes. And don't implement explicit lazy loading where you accept the ILazyLoader interface in your domain classes. This is a glaring violation of the separation between domain modeling and ORM concerns. Entity Framework's DbContext implements the identity map pattern. The identity map is a cache of all objects that have been read from the database within a single business transaction. When you ask DbContext to load a student, EF Core first looks it up in the local cache and only if it's not there tries to retrieve it from the database. To gain all the benefits of the identity map pattern, use the Find method to retrieve a single entity from the database, not Single or First extension methods. The Find method both reads and writes to the local cache of the DbContext, while Single and First only write to that cache, meaning that they do record the result of the local cache. But if you ask them to load the same object again, they will do another roundtrip to the database instead of taking that object from the cache. Aside from performance improvements that come from caching, the other benefit of the identity map pattern is referential equality. If you request the same object two times, the DbContext will give you two references to the same object in memory. It's important to encapsulate the equality comparison in entity classes. The client code should only use the equality operator to convert to entities. All the complexity should be hidden in that operator. Put the equality comparison logic in the base entity class. All your entities can then reuse that logic just by inheriting from that base entity class. In the next module, we'll discuss mapping to backing fields and working with one‑to‑many relationships.
Mapping Backing Fields
Introduction

Hi. My name is Vladimir Khorikov, and this is the course Domain‑Driven Design and EF Core: Preserving Encapsulation. In this module, we will talk about one‑to‑many relationships and using backing fields to map those relationships. You will also see the shortcomings of EF Core when it comes to mapping backing fields and how to overcome those shortcomings.
Introducing a One-to-many Relationship: Part 1

To demonstrate the work with one‑to‑many relationships, I will add enrollments to our sample application. In terms of the database, here's how our application looks at the moment. And here is how it looks after the addition off the new enrollment table. I've already added the database migration script. You can find it here. Just run it on top of the initial script, and it will add the enrollment table to your database. I've also added the Enrollment class. It has structure similar to that of Student. All properties are read only, and it has two constructors, one accepting all parameters for the public use, and they are the ones with no parameters to enable lazy loading. You can also see the grade here. Alright, and before we start discussing the work with enrollments, I want to do one more thing, I want to emulate a typical ASP.NET Core application structure in our console app, so that it looks familiar. For that, I'm adding a new class, StudentController. Note that it will not inherit from any built‑in ASP.NET Core controllers because again, this is just for familiarity purposes. I will break down all our application code into controller methods, which will correspond to typical business use cases. So, just as with a regular ASP.NET controller, we will inject the DBContext into that controller's constructor. Right now, we have this code here, which we used to test equality operations in the base entity class. And although this code seems arbitrary, there's actually a good use case for it from a business perspective. For example, the customer might want to know if a student has chosen a particular course as the favorite one. So I'll represent this use case as a controller method called CheckStudentFavoriteCourse, which will accept a student and courseId. Again, remember that this controller is not part of the domain model, and so it's perfectly fine for that controller to operate IDs of the entities. There is actually no other way to orchestrate business use cases in application services, you have to use IDs. I'm copying this code here, replacing the context instance with the one we injected into the controller, and ID with a studentId argument. Good. If the student is null, then return Student not found. Now, instead of selecting the course from the database, as you see here, I will add a static method to the course class that would find the course by its ID. That will save us a round trip to the database, since our course is full of the enumeration pattern, and we already have them listed it in our Course class. So, I'm introducing a new property called AllCourses, and a new method that would iterate through these courses and return the requested one, or none at all if the course is not found. Now I can call FromId, and pass the courseId argument. Check in the Course for null as well, and returning an error message. Finally, if the student's FavoriteCourse equals that course, we'll return Yes, otherwise, no. Deleting all of this, very good. In the Program class, I'll add a new method that will help us to execute controller methods. This method will instantiate a new new context. Of course we need the connection string here. Then it will create the controller and pass it as an argument to the delegate. And let me disable this warning from Visual Studio. It tells me that I can simplify the using statement, but I personally don't like this new syntax. Okay, this is pretty much how ASP.NET dependency injection works in real life too. To use this helper method, I just need to call execute, and specify the controller method I want to invoke, saving the result, and let's test that this method is working. As you can see, it is working. The result is Yes, which means the controller correctly recognized the course with ID 2 as the favorite analysis course. We will add a use case related to enrollments to this controller shortly. But first, let's introduce the one‑to‑many relationship itself, between the student and enrollment classes.
Introducing a One-to-many Relationship: Part 2

I will first add to the one‑to‑many relationship between the student and enrollment classes the conventional way, meaning the way it is usually done without regard to encapsulation. Then we will discuss its drawbacks and refactor toward encapsulation. To add the relationship, we need to introduce a collection of enrollments in the Student class and in the DbContext. Map the Enrollment class itself and add the collection of enrollments in the Student mapping. Note that you don't have to map all the properties manually like I do. EF Core does a pretty good job mapping them in classes automatically using conventions. It's just my personal preference. I like to map all properties explicitly. Let's run this existing use case to make sure the mapping is working. And you can see that the enrollment collection has been populated. There is currently no enrollments in the database, but the fact that there are no exceptions means everything is working. Now to the new use case involving enrollments. That use case will be addition of a new enrollment where the customer can specify which student they want to enroll, to which course, and with what grade. I'm copying the code for finding the student and the course, use the student's enrollment collection to add a new enrollment, and return OK. And, of course, I also need to call context.SaveChanges to persist the enrollment in the database. Let's test the new use case, running the application. Very good. It returns OK, meaning that the enrollment is added successfully. And if you go to this old method and add a breakpoint here, you can see that the enrollment has been successfully added to the collection of enrollments. The course is chemistry, and the grade is A just as we requested in the previous controller method call.
Recap: Introducing a One-to-many Relationship

In the previous demo, we introduced the one‑to‑many relationship between students and enrollments. As you might remember from module three, such relationships are represented with the collection on the one side and with a reference on the many side. Here, the one side is student, and the many side is enrollment. We've added the enrollment collection to the student class as an ICollection property. And here's how we used that collection in the student controller when we added a new enrollment. This is a common way programmers deal with collections in Entity Framework. But as you might have already guessed, it is also incorrect. This approach damages the students encapsulation by introducing a to large surface area for potential bugs. For example, the client code can easily clear the collection of enrollments. There is nothing preventing it from doing so, or it can assign it a new collection or turn it to null, that's possible too. Still, none of these operations are meaningful because there is no such use case in our domain model as deleting all students enrollments. And even if there were such a use case, giving the controller the full access to the enrollment collection is not how it should be implemented. So again, the student class provides too wide an API surface area, including the APIs that allow for legal operations upon that class. We need to reduce that surface area and expose only the absolute minimum of functionality and also make sure that that functionality cannot possibly violate any invariants in our domain model. So let's do that.
Hiding the Collection Behind a Backing Field

Collections is one of the most common ways people damage encapsulation of their domain classes. Here, we do that twice. First, by exposing the ICollection interface, which allows for collection mutation, and second, by exposing the public setter, which allows for assigning a new collection to this property. This is where back‑end fields come into play. We can hide the mutable collection behind the private back‑end field while exposing a read‑only collection in a public property. So let's add the back‑end field with a mutable list, change the type of the property from ICollection to IReadOnlyList, and make these property a proxy on top of the back‑end field with no setter. Calling to list ensures that the original collection remains unchanged, even if the client performs a manual cast from IReadOnlyList ToList. Some people prefer to use IEnumerable in place of IReadOnlyList, but I don't recommend doing so. One of the API design best practices is returning the most specific type you possibly can while still maintaining all the invariants. The invariant is that the client call should not be able to modify the enrollment collection. Both IEnumerable and IReadOnlyList maintain that invariant, but IReadOnlyList is a more specific type, and that should be preferred over IEnumerable. The main reason why is that the more specific type provides more functionality to the client code. For example, IReadOnlyList contains account property, while IEnumerable does not. With IEnumerable, you would have to resort to LINQ extension method to count the number of elements in the collection. All right, now that the mutable collection is hidden, we need to provide the means for the client code to add an enrollment. For that, I'm introducing an AddEnrollment method that accepts a Course and the Grade. Inside of that method, we instantiate an enrollment and add it to the collection of enrollments. Now in the StudentController, I'm calling student.AddEnrollment and pass the course and the grade, and remove the old version. Very good. Note that it's always better to use the ubiquitous language of your problem domain in your code, especially in the domain model. So a better name for this method, instead of AddEnrollment would, be EnrollIn because that's how the customers of our software describe the act of creating an enrollment. They describe it as enrolling students in courses, not adding enrollment. The same goes for the controller, so I am renaming this method into EnrollStudent. And let's also modify the mapping. Note that, as I mentioned earlier, if core already binds to back‑end fields by default, and that's true for all properties, with or without explicitly defined back‑end fields. So our code will work as is, if core will apply naming conventions and will discover the enrollments back‑end field automatically. But I will still add explicit mapping just to show you how it can be done, in case you ever need that. Here, we need to drill down into the metadata of the navigation property, go to the PrincipalToDependent property, and then send the AccessMode. In Entity Framework Taxonomy, principal stands for the one side of the one to many relationship, and dependent stands for the many sides of that relationship. Again, in our case, student is that the one side and enrollment is the many side. All right, let's check if our application is still working. Running it, the result of the student enrollment is okay, which means the enrollment was successful. And if we go to the student itself, we can see two same enrollments. Very good.
Recap: Hiding the Collection Behind a Backing Field

In the previous demo, we encapsulated the collection of enrollments. We did that by removing the setter on that property and exposing the read‑only collection instead of a mutable one. That explicitly tells the client of this class that they cannot directly mutate this collection. We also added a new method in Student which is responsible for enrolling that student in a course. Notice that this method doesn't accept an enrollment instance, but instead accepts a course and a grade and then creates an enrollment on its own. This is almost always the case for one‑to‑many relationships. The entity on the one side of the relationship, the student entity, should be fully responsible for creation of entities on the many side, the enrollments in our case. In terms of domain‑driven design, the entity on the many side is an entity internal to an aggregate. Here the student aggregate contains two entities, the student itself, which is the aggregate root, and the enrollment entity, which is not an aggregate root. Refer to my Domain‑Driven Design in Practice course to learn more about aggregates. Also notice that I didn't add a DbSet of enrollments to our DbContext. This is also because enrollment is an internal entity, which means that its lifetime should be fully controlled by the aggregate root, the student entity in our case. As a general rule, don't introduce DbSets for internal entities. Such internal entities almost always reside on the many side of the one‑to‑many relationship.
Introducing a Collection Invariant

If you watched my previous courses about domain driven design, you already saw this technique of collection encapsulation in the course about refactoring away from anemic domain models. I used NHibernate in that course, though not Entity Framework. And there are some caveats related to encapsulating collections when it comes to EF Core. And those caveats are best expressed with an example, so let me show you one. Let's say that there is an invariant in our domain model saying that we cannot enroll a student into the same course twice, and if the client tries to do that, our application should return an error. To implement this requirement, we need to modify the enrollment method. First, make it return a string instead of void. Next, check the existing enrollments. If there are any enrollments with the same course, then return an error saying that the student is already enrolled in this course, and if everything is fine, return OK. In the controller, save the execution result in a variable and return it afterwards. Note that I'm cutting corners here with such an error handling. In the real world application, you would probably want to return an object of a fully‑fleshed class that denotes the result of the operation. This class is usually called just that, result. You can find an implementation of it in my course about functional programming. In that course, you will also find a more in‑depth information about proper error handling. For our demo, though, a simple string is enough. Just keep in mind that you don't want to use such a string in the production code base. Alright, to test this implementation, I will run the same code that enrolls Alice in the same course, but first, let me remove the second enrollment we've added during the previous test run. Good. Now Alice has only one enrollment in chemistry. Let's run the application and you can see the problem here. The controller has successfully added the second enrollment into the same course in spite of our validation code. If I go to the database, you can see the second enrollment was added with identical data. Let's drill down to the Student class and see why this is happening. Putting a breakpoint here and running the application again. As you can see, the enrollment collection is empty, and that's why this validation always passes because EF Core simply doesn't load the student's enrollments. The reason why this behavior takes place is because of the way Entity Framework implements lazy loading. It only loads the collection when you refer to the property itself, it doesn't intercept calls to backend fields. So if I navigate to the property, you can see that it shows the number of enrollments correctly. That's because Visual Studio has reached out to this property behind the scenes, and therefore, prompt EF Core to initialize this collection. Now if I go back to the enrollment method and look into the backend field, this field also shows the correct number of enrollments. Unfortunately, this is a fundamental flaw in how EF Core approaches lazy loading. If you worked with NHibernate, you might remember that it requires you to mark all public members as virtual, not only navigation properties like EF Core. So if I were to migrate this application from EF Core to NHibernate, I would have to mark as virtual not only these two properties, but these two as well, and also, the enrollment method. That is done for this exact reason to intercept calls to the backend fields and initialize any collections before you start using those collections. In other words, NHibernate will do something like this, it will create a runtime proxy on top of student just like EF Core does, but in addition to the navigation properties, it will also override the enrollment method where it will initialize the enrollments backend field before passing the control to your own code. EF Core does that only for navigation properties. To overcome this issue, we will have to resort to eager loading of the enrollment collection. There are two ways to do that, one is to include the enrollments and then use the one of the link extension methods, such as single. Notice that this include only works in combination with link extension methods. You cannot use it along with the find method. That's because find is a method in the DbSet class itself, whereas, include returns an IQueryable interface, which you need to query through link extension methods. Alright, let's test it, and you can see that the inclusion of enrollments worked. The backend field has been successfully initialized, and the controller now returns a proper error message saying that the student is already enrolled in chemistry. Let me comment this out. Okay, the second approach is to use the find method and then initialize the enrollment collection explicitly like this. Let's do a quick run to make sure the collection is still being initialized, and you can see that it indeed is. Both Alice's enrollments are in here. As I mentioned earlier, both of these approaches have their pros and cons. The approach with include allows you to retrieve the student and its enrollments in one database roundtrip, but it doesn't play well with identity map pattern, which we discussed in the previous module, meaning that if you request the same student two times within the same DbContext, EF Core will make two database calls, even though it would have the student in the memory cache. The approach with a find method doesn't have this issue and will not make the second call to the database if the student was loaded previously, but it will make two database roundtrips, instead of one. It will first load the student itself and then it will load the enrollments. I recommend to use the approach with the find method by default. It plays well with identity map pattern, and although, it generates two database requests instead of one, they are simple and thus easier to understand and debug if needed, especially in scenarios with multiple one‑to‑many relationships. To encapsulate these additional and quite unfortunate complexity related to student retrieval, I will introduce a student repository. Generally, when working with EF Core, you don't need repositories because often they don't add any value compared to the vanilla DbContext, but in situations like this where we have any additional complexity related to retrieving or saving them in objects to the database, you do need the repository to encapsulate that complexity. Our repository will be a wrapper on top of the DbContext. It will accept the DbContext in a constructor and save it to a private field. It will also have one method, GetById, that would return a student given its identifier. Let me make the DbContext read only, and we also need to check if the student is in the database because if it's not, the time to load its enrollments will throw an exception and return it. Good. Going back to StudentController, instantiating the repository in the constructor, saving it to private field, and now it can replace the old code retrieving the student with that repository. Commenting these two lines, let's test the application. Very good. The enrollments have been loaded from the database. Removing the comments and this line here. Perfect.
Recap: Introducing a Collection Invariant

Alright, there is a lot to recap, so let's do that one point at a time. We've introduced a new requirement to our application. A student cannot be enrolled in the same course twice, and if the customer tries to do so, the application should return an error. To address this requirement in the domain model, we added new code to the students enrollment method that checks if the student already has any enrollments with the same course and, if so, returns an error. This is perfectly valid code from a domain modeling perspective, but it doesn't work. This check here always passes, meaning that we never get an error from the enrollment method, even if the student already has an enrollment with the same course. The reason why is the way Entity Framework implements lazy loading. It has a fundamental flaw in this implementation where it only intercepts calls to navigation properties, but not to other properties or methods. In other words, EF Core does something like this. It creates a runtime proxy similar to this class and overrides calls to the enrollments property where it first initializes the BackingField, and only then passes the execution to your code, whereas NHibernation, in addition to the navigation property itself, also overrides the enrollment method the same way and thus doesn't have this issue. By the way, this is why NHibernate requires you to mark as virtual all public members, including methods, and not just navigation properties. Unfortunately, because of this issue, you have to forgo lazy loading in such scenarios and load the collection eagerly. There are two ways to do that, using the Include method and then calling the SingleOrDefault LINQ extension method or using the Find method and loading the relationship explicitly. The SingleOrDefault extension method has a benefit of retrieving the student itself and its enrollments in one database round trip, but doesn't work well with identity map pattern, meaning that it doesn't honor the cache of already‑retrieved objects in the DbContext. The Find method issues two requests to the database, but works well with the identity map pattern and will only retrieve the student from the database once, regardless of how many times you ask it to. I recommend that you use the Find method by default. The SQL it generates is easier to debug, and the fact that it honors the cache of the DbContext is also good. There is another alternative to handling this issue, and that is the use of the Enrollments property, not backing field, when performing this check. It solves the problem with lazy loading because the use of the navigation property triggers the collection initialization, but I don't recommend this approach because it's extremely error prone. First, it's not obvious at all when reading this code why we are using the backing field to add a new enrollment but the navigation property to read the enrollments. And it's too easy to make a mistake and use the backing field in both cases, which is a perfectly valid inclination but would result in a bug. Second, such code violates the separation of concerns principle. The only reason why we are using this property here and not the backing field is to satisfy the ORM, meaning that this code now addresses both the domain modeling and the ORM concerns. Resort to this way of handling this issue only as the very last option when all other alternatives are exhausted. To maintain proper separation of concerns, use the Find method in combination with explicit loading of the related entities. This additional complexity of retrieving entities from the database, or saving them to the database for that matter, is where you need repositories to encapsulate that complexity away from the controller. You don't need to introduce repositories otherwise. Note that although we are now using the repository to retrieve students from the database, we still need the DbContext. We are using it to commit changes to the database. This is the responsibility that cannot be delegated to a repository, and must stay within the unit of work class. The DbContext plays the role of such a unit of work. It allows you to either commit or discard changes in domain objects that are accumulated during the business transaction.
Deleting an Item from the Collection

So far in this module, we discussed two use cases related to one‑to‑many relationships, retrieving the collection of related entities from the database and adding a new item to that collection. Let's now talk about how to delete an item. So let's say that we've got a new requirement. The customer wants to be able to disenroll a student from a course. For that, I'm adding a new method to the StudentController called DisenrollStudent, copying this boilerplate, saving the changes, and the returning an OK. The disenrollment should be handled by the Student class similarly to the enrollment functionality. So I'm creating a new method, Disenroll, that accepts a course we want to disenroll the student from. Inside of this method, we are finding the first enrollment to the specific course and, if it is found, removing it from the enrollment collection. To test this use case, let's go to the Program file and execute this controller method. I am passing the same student and course ID we used in the enrollment use case. Let's run the application, and you can see that EF Core has thrown an exception. That's because, by default, EF Core handles the deletion of items from a collection of related entities by setting the principle key to null. In our particular case, it means that EF Core tries to set the StudentId in the deleted enrollment to null, which is obviously not a correct behavior because enrollments cannot leave on their own without a student. And so the StudentId column in the enrollment table in the database is not nullable. To fix this, we need to tell EF Core that when we remove an enrollment from the collection of enrollments, EF Core should delete that enrollment from the database as well. This cascade delete behavior does exactly that. Let's run the application, and you can see that the operation was successful. And if I go to the database and refresh this query, you can see that the student now has only one enrollment. Very good.
Recap: Deleting an Item from the Collection

In the previous demo, you saw another typical use case associated with one‑to‑many relationships, deletion of an item from a collection. Just as an aggregate root should be fully responsible for creation of internal entities, it should also be fully responsible for their deletion. In our scenario, the Student class is the aggregate root, and enrollment is an entity internal to the Student's aggregate. Removing the internal entity from the aggregate roots collection should be enough for deleting that internal entity, because no other entity should keep a reference to internal entities of other aggregates. We simulated this behavior by setting up a cascade deletion in EF Core using these line of code. This is a relatively recent addition to EF Core, and a good one, because it helps you to maintain the separation of concerns. In earlier versions of Entity Framework, in addition to removing the enrollment in the domain model, you had to also manually mark it as deleted in the DbContext so that it would get deleted during the call to save changes. Now, thanks to this new feature, you don't have to do that.
Shortcomings of Mapping to Backing Fields in EF Core

The EF Core team has done a pretty good job overall, enabling mapping to backing fields, but there still are a couple issues with its implementation you need to be aware of. These issues are related to restrictions EF Core puts on the type of the navigation properties and their backing fields, and that is the type of the backing field must be the same as the type of the navigation property, or it must be a subtype of the Properties type. For example, I cannot make the Enrollments backing field an ICollection like you can see here. This code would throw an exception because of the type of the backing field the ICollection does not inherit from IReadOnlyList. To make it work, I have to either change the type of the property to IEnnumerable, or change the type of the backing field to List. Both of these options work because ICollection inherits from IEnumerable, and List inherits from IReadOnlyList. I'm not sure why EF Core imposes this restriction, though. It seems completely unnecessary. In this particular scenario it's not a big deal, of course, because the combination of List and IReadOnlyList works fine, which is exactly the combination I recommend. But there are situations where this restriction prevents you from implementing some more advanced mapping techniques. One of such techniques is using a custom type for navigation properties. A good example here is nullable reference types. Let's say that in our domain model, a student may or may not have a favorite course, meaning that that favorite course becomes optional. Right now it's a mandatory field. This new requirement translates into this property in the Student class, becoming nullable. Let's also say that you want to make this fact explicit for the client code and change the type of this property from course to Maybe<Course>, where Maybe is a wrapper similar to the built‑in nullable type from .NET. Of course, the ORM wouldn't know how to map this type, and so the common technique here is to introduce a private backing field of type Course and map your database to that backing field. But it wouldn't work in EF Core because of this restriction I mentioned earlier, where the type of the backing field must always be a subtype of the type of the navigation property. Note that it does work for simple properties like email or name, but not for references to other domain classes, navigation properties like the student's favorite course. There is no such restriction in nHibernate, so again, I'm not sure why this restriction was introduced in Entity Framework. Also note that in C# 8, there is a similar syntax where you can mark nullable reference types with a question mark and receive compiler warnings when you use nulls where they aren't supposed to be used. But that new feature is inferior to the approach with Maybe, since it doesn't provide as strong compiler and runtime guarantees of non‑nullability. You can learn more about the use of the Maybe type and non‑nullable reference types in general in my course about functional programming in C#.
Summary

In this module, you learned about one‑to‑many relationships and the use of backing fields to encapsulate those relationships. We've introduced enrollment functionality in our application, where a student can be enrolled into several courses. The relationship between students and enrollments is one‑to‑many, where a student resides on the one side and enrollment on the many side. We have encapsulated the work with enrollment collection in the Student class. Make sure that you never expose mutable collections to the client code. Always make those collections read‑only by hiding the setter and by exposing them as an IReadOnlyList. To add or remove items from the collection, introduce separate methods in the class container. We've introduced an invariant related to the enrollment collection. That is the customer cannot enroll student into same courses. To enforce this invariant, we had to load the enrollment collection eagerly. That's because of the fundamental flaw in the way EF Core implements lazy loading. It only intercepts calls to navigation properties themselves, but not to other properties or methods and thus doesn't initialize backing fields when you refer to them from class's methods. To encapsulate the logic of loading the student along with its enrollments, we introduced a student repository class. We have also implemented the use case of deleting a student enrollment. To do that, we only had to remove the enrollment from the students collection of enrollments and set up a cascade deletion in EF Core. Note that in both cases the addition of enrollment and the deletion of the Student class fully controls the lifetime of those enrollments. That's because the student is an aggregate root, and the enrollment is an entity internal to that aggregate. We also discussed the shortcomings of mapping to backing fields in EF Core. It imposes restrictions on the type of the navigation properties and their backing fields. That is the type of the backing field must be the same as the type of the navigation property, or it must be a subtype of the property's type. It's not that big of a deal for collections, but it is quite a big deal if you try to implement strict nullability in your domain model using a maybe type. In the next module, we will discuss working with disconnected graphs of objects.
Working with Disconnected Graphs of Objects
Introduction

Hi. My name is Vladimir Khorikov, and this is the course Domain‑Driven Design and EF Core: Preserving Encapsulation. In this module, we will talk about working with disconnected graphs of objects. You will see how to use entities that live outside of the DbContext in such scenarios as creating a new domain object or updating an existing one.
New Use Case: Registering a Student

So far in this course, we worked with students that already existed in the database. We have implemented scenarios for checking their favorite course, enrolling and disenrolling them from a course. Let's now talk about a scenario that involves creation of a new student. I'll use that scenario to illustrate key points about disconnected graphs of objects that you need to be aware of. The scenario itself is going to be registration of a new student. To implement it, I'm adding a new Controller method that accepts all the student information, their name, email, and favoriteCourseId. Let me copy this boilerplate from here, CourseId and the name of the variable. The domain model part of the registration use case is pretty simple. I'm just calling the Students constructor and passing all these three fields as arguments. Note that I am omitting the validation of name and email for now. We'll come back to this topic in the next module when we'll be discussing value objects. Now, after the student is instantiated, we can call context.Students.Add, SaveChanges, and return "OK". Let's go to the Program class and see what happens if I run this code. Calling the new controller method, and let's say we want to register Carl, whose favorite course is calculus with ID 2. Let me comment this, put a breakpoint, and run the application. And you can see that EF Core has thrown an exception. Our seemingly valid code didn't work, and that is because EF Core tried to insert not only the student itself, but also its favorite course, which, of course, was not supposed to be inserted because that course is already in the database. In this particular case, EF Core complains that the ID column in the Course table doesn't support automatic assignment of new ID values, which in SQL Server terminology, is called IDENTITY_INSERT. Of course, there should be no IDENTITY_INSERT because the list of courses is reference data, and it should be managed by database migration scripts, not the application. To illustrate why this exception takes place, let's see what states EF Core assigns to the student and FavoriteCourse entities after adding the student to the DbSet. And you can see that both of these entityStates are added, meaning that EF Core treats both of them as new objects that have to be inserted into the database. If I press F5 and try to save these changes, you can see in the SQL Profiler that I am to insert the Chemistry course. It is this attempt that throws an exception.
Recap: Registering a Student

The reason why EF Core tries to insert both the student and the favorite course is because of the way the add method is implemented. When you add an object to the DbSet, EF Core marks as added not only of that object itself, but it also traverses the graph of reachable objects inside that first object and marks them as added, too. And just a quick reminder on what entity states there are in EF Core; there are five of them. The detached state means that the DB context doesn't know about this object and doesn't track it at all, and changed means that the object is tracked, but has no changes since the time it was queried from the database; deleted, that the object exists in the database and will be deleted once you call Save Changes; modified, that the object has changed since when it was retrieved from the database and will be updated; and finally, added, that it's a newly instantiated object and will be inserted. So EF Core marks both the student and its favorite course as added, but why does it do that? It's because the favorite course is disconnected from the DB context. In other words, it is detached, just like the newly instantiated student. And when you add a detached object to the DbSet, EF Core treats that object as new. Here, you can see we get the course from this method, which itself gets it from the in‑memory cache of courses that we maintain manually using the static properties. And if I go back and instead get the course from the DB context, and pass this course to the student constructor, you can see the favorite course, state is now unchanged, not added, which is the correct state, because we didn't add to this course, nor did we update it. And if I press F5 and go to the database, you can see that the new student has been successfully inserted. Of course, we don't want to retrieve courses from the database. That would completely defeat the purpose of the enumeration pattern. So how should we handle the situation where we've got a mixed bag of detached objects, some of which are genuinely new objects and some already exist in the database? In earlier versions of Entity Framework, you have to manually assign the correct state to some of the detached objects like this, which was quite a pain, I must say, especially if you had a large graph of objects, because you had to traverse that graph manually. And just to illustrate this idea with large grasp of detached objects real quick, let's say that when we register a student, we should not only assign the favorite course to that student as favorite, but we also need to enroll the student in that course. So I'm adding the favorite course as grade in the controller, same for the student's constructor, and enrolling the student into the favorite course with a specified grade. Note that we are enrolling the student in the constructor at the time of initializing that student, and we don't rely on the controller to do that. This is once again to preserve encapsulation and make sure that there is no way for the client code to break the new invariant, which is that all newly registered students must be enrolled into their favorite course. So passing the grade to the students' constructor and of course, instead of retrieving the course from the database, we need to bring back the old code that uses the enumeration pattern. We have two new objects here: the enrollment itself and the course in that enrollment. So I'm getting the states with these two new lines. I need to add the grade in the program file, too. Let it be a B, and you can see that we now have a lot more work to do to manually differentiate between added and changed objects. If Core has marked all four of them as added, and so we would have to manually change the state off the favorite course, but not the student, and we would also have to change the state of the enrollments course, but not the state of the enrollment itself. Luckily, EF Core now provides a way for us to automate all this manual labor. Let's see how we can do that.
Update and Attach Methods in DbSet

Instead of manually setting the State of the entities in the aggregate, we can use that the Attach method from the DbSet class. The difference between Add and Attach is that the Attach method doesn't just mark all detached objects as added, but instead it looks at their IDs to determine their State. If an object Id property has the default value, such a 0, then this object will be treated as new, and its State will be sent to Added. And if the object's Id is not 0, then the Attach method will set this object's State to Unchanged. And that is exactly what we need because the only thing that differentiates newly instantiated detached entities from already existing detached entities is their Id. New entities don't have an Id yet, while existent entities do. The way it works is when you instantiate a Student, its Id is 0 because, as you may remember, we don't set the Student's Id explicitly anywhere. We delegate this to EF Core. EF Core, in turn, sets the the Id either during the call to SaveChanges or when you add the entity to the DbSet, depending on the Id generation strategy. In our particular case, we rely on the SQL Server's identity insert, in which case, EF Core sets the object's Id after it inserts that object to the database during the call to SaveChanges. So let's replace Add with Attach and see what happens, running it, and you can see that the Attach method worked exactly as expected. It has marked the Student and the Enrollment as Added and correctly recognized the both the FavoriteCourse and the Enrollments Course as and Unchanged, which is exactly what happened in this use case. We've created a new Student and the new Enrollment object, but used an already existing course for these two objects. Note that in addition to the Add and Attach methods in the DbSet class, there is also an Update method. It works similar to Attach, but instead of marking entities with non‑0 Ids as Unchanged, it marks them as Modified and then updates during the call to SaveChanges. This is not how you want EF Core to categorize such entities because that would lead to unnecessary database round trips to update entities that haven't been changed. Let me demonstrate this behavior. If I change Attach to Update and run the application, you can see that the Student and the Enrollment are added just as before, but the Course State is now modified, which means that if I press F5 and go to the SQL Profiler, we will see here that two expected Insert statements, one for the Student and the other one for the Enrollment. But in addition to them, we can also see that if Core updated, the course's details, which was completely unnecessary because that course hasn't been changed and cannot be changed since it's referenced data that shouldn't be modified by the application at all. Note that there was only one Update query and not two because we are using the same course instance for both the Student's FavoriteCourse and the Enrollment. So always prefer Attach when adding newly instantiated objects to the DbContext, not Add or Update. Notice that there is a deeper guideline behind the advice of always preferring the Attach method over Update, and that is you should never modify domain objects outside of the DbContext they originated from, meaning when those objects are not being tracked by the original DbContext. Let me elaborate on this guideline. The common anti‑pattern and the main use case for the Update method is using domain classes in place of DTOs. This anti‑pattern usually looks like this. You accept a Student object in the controller and save it to the database using the Update method. The reason why this is an anti‑pattern is two‑fold. First, the Student class might contain sensitive properties that you don't want to be set by the client application, such as, for example, the student's status in the university. A malicious client can send that status alongside the other information about the student, and it will be materialized and saved to the database. Second, the use of the domain model in place of DTOs makes it harder to maintain backward compatibility. I explain these issues in much more detail in my course about anemic domain models. Check it out if you haven't already. There should be a strict line between data you except from outside world and your domain model, and so never allow your domain objects to be modified outside of the DbContext. Use DTOs to accept external data, parse and validate the data, load objects from the database, and only then modify them. The only legitimate use case for domain objects that are not connected to a DbContext are cached domain objects. In our particular case, Course is the domain class whose objects are cached and thus are not connected to any DbContext, and we should never modify such objects. There is an exception to this guideline, and that is desktop applications, such as WPF or WinForms, or long‑running background processes. With such apps, you basically have the client and the server merged into one application. Also, you don't have a clear account response request pattern, like in client/server applications, and so modifying the domain objects while those objects are not connected to a DbContext is justified in such applications.
Recap: Add vs. Update vs. Attach Methods in DbSet

Alright, let's recap what we did so far. We have introduced a new controller method that is responsible for registration of new students. In that method, we end up with a student aggregate that consists of four entities, all of which are detached from the DbContext, the student itself, its favorite course, the enrollment to the favorite course, and the enrollments course. Although all four entities are detached, only two of them are new, the student and the enrollment. The other two already exist in the database. When we tried to save this aggregate using context.students.add method, EF Core marked all of those entities as added and attempted to insert them into the database, which of course resulted in an exception. To fix of this issue, we used the Attach method instead. Unlike the Add method, Attach doesn't just mark all entities in the aggregate as added. It instead categorizes them into added and unchanged by looking at their IDs. Entities with a default ID value are marked as added, while entities with a non‑default ID as unchanged. There is also the Update method in the DbSet. It works similarly to Attach. But instead of marking entities with non‑default IDs as unchanged, it marks them as modified. The only use case for the Update method is when you modify domain objects while those objects are not connected to a DbContext, which is an anti‑pattern in client server applications. Don't modify domain objects outside of a DbContext. Prefer the Attach method over Update. The only exception to this rule is if you develop a desktop application or a long‑running background process. Note that just like we've hiding the student retrieval logic behind the student repository, it's a good idea to hide the saving logic behind that repository as well. It will help you to avoid confusion as to which method to choose when saving a newly instantiated student. So let's do that real quick. In the student repository, I'm adding a method called Save that will accept Student. Note that I'm naming this method Save and not Add or Update to avoid confusion with existing methods in Entity Framework's DbSet. Let me make it sealed so that this warning from ReSharper goes away. Now in the controller using the repository instead of the DbContext, and I can remove all this and this comment here too. Good.
Assigning a Disconnected Entity to a Connected One

In the student registration scenario, we worked on assigning a detached and existing entity to an entity that is also detached but new, not existing. The student was that new entity, and the course was the existing detached one. Now let's talk about assigning a detached existing entity to an entity that is being tracked by Entity Framework. In other words, we will assign a new favorite course to an already existing student. For that, we'll introduce a new business requirement, adding the student's personal information, which we'll represent with yet another controller method. This controller method will accept the student's information and, of course, the student's ID. Copying this boiler plate here, changing the course ID. Okay to modify the student's personal information, we will use that the properties in the student class. And let me rename course to favoriteCourse. Good. These properties currently have no setter, so I'm adding it to all of them. Note that making setters public is not the best way to handle this requirement in the domain model. We'll talk about it in more detail in the next module. For now, public setters are good enough to demonstrate this use case. And to test this code, I need to call the new controller method in the program class. EditPersonalInfo, Carl's ID is 13, and we'll change this favoriteCourse to calculus, which has ID 1, and his name to Carl 2. Running the application. The result is OK, which means the data editing was successful. But if I go to the SQL Profiler, you can see the retrieval of the student and the retrieval of the enrollment, which is expected. And you can also see the update of the student's favorite course and name, which is also expected. But there is also an update of the calculus course, which is not expected at all since we didn't change it. So what's happened is when we assigned the student a new course, and remember, that course is a detached object, EF Core marked that course as modified and updated it during the call to save changes. Let's bring back these lines here that we used during student registration to demonstrate what's going on. Running the application, and you can see that the student is modified and the enrollment is unchanged, which is good, but the course is modified. Again, that's because this course was a detached entity, and when you assigned a detached entity to an entity that is being tracked by the DBContext, EF Core starts to track their detached entity too, and marks it as modified. We did that assignment in this line. The student is the entity being tracked by the DBContext, and the new favorite course is a detached entity. This is a quite unfortunate behavior. A better way of implementing this would have been to treat the course as unchanged by default, and only if it's modified while being tracked by the DBContext should EF Core treat that course as modified. It's unfortunate because now we have to take additional steps to mark the course as unchanged. One way of doing so would be to assign the entity state manually, right here in the controller. This solution violates the separation of concerns principle though, because now the controller is becoming responsible for not only coordinating the work between the domain model and out of process dependencies, but also for the mapping between the domain model and the database, which is clearly a concern that the RM should be responsible for. Luckily, there is a way to map the course class such that if Core will not update it after calling save changes. And that is assigning this SetAfterSaveBehavior to ignore. This tells EF Core that after the entity is persisted to the database the first time, it should not change. Note that if there were other properties in the course class, you would need to apply this setting to those properties as well. This solution is not ideal, though, because the entity is still treated as modified. It's just EF Core doesn't do anything about it. So if I remove all this, go to the program file, and run the application, operation successful. Good. And if I open SQL Profiler, you can see that the retrieval of the student and its enrollment is here, as well as the student update. But there is no course update, which is exactly what we need. Another and probably better solution to this problem is to override the SaveChanges method like this. Here we mark all courses that are being tracked by Entity Framework as unchanged so that they are never inserted or updated. I don't like any of these two solutions because they are basically hacks for the self‑inflicted problem, and we wouldn't need them should EF Core implemented entity attachment functionality differently. But at least these hacks are contained in the mapping code and don't leak to the controller or domain model. Let me comment this method. I'll leave it here for your reference.
Recap: Assigning a Disconnected Entity to a Connected One

In the previous demo, you saw an example of assigning a disconnected entity to a connected one. The disconnected, or detached, entity was the new FavoriteCourse that we assigned to the connected, or attached, student. When you connect a detached entity, course, in our case, to an attached one, student, EF Core attaches that detached entity to the DbContext and sets its state to Modified, and then does an additional unnecessary round trip to the database to update that entity. This is an unfortunate behavior and should have been implemented differently. It's better to treat the previously detached entity as unchanged by default and only set its state to Modified when it's changed while being tracked by the DbContext. To fix of this behavior and avoid the unnecessary database round trip, while at the same time preserving separation of concerns, you need to either SetAfterSaveBehavior for all of the course's properties to ignore, or override the SaveChanges method, such that all courses are marked as unchanged before persisting changes into the database.
Summary

In this module, we discussed how to work with disconnected or detached graphs of objects. We've introduced a new use case, student registration. During that use case, we were assigned a detached, but already existing course to a newly instiated student. We then try to use DbSet.Add method to save that student. It didn't work because EF Core marks all detached entities in the aggregate as added in such a case, regardless of whether they already exist in the database. We fixed this issue by using the attach method instead of add. Unlike add, attach looks at the entity's IDs to determine their state. If the ID equals the default value, such as 0, then the entity is marked as new, otherwise, as unchanged. The DbSet class also has an update method that works similarly to attach, but instead of treating objects with a non‑default ID as unchanged, the update method treats them as modified. Always prefer attach over update or add. In fact, the use of update contradicts an important guideline and that is you should never modify a domain object while it is not tracked by the DbContext. Such a modification is a red flag indicating that the Domain class is used in place of a DTO. The only exception for this guideline is desktop applications or long‑running background processes. We also introduced another use case, editing student's personal information. During that use case, we assigned a detached course to a student that was being tracked by the DbContext. Unfortunately, when EF Core starts to track a previously detached entity this way, it marks that entity as modified, which leads to an unnecessary roundtrip to the database. To fix this, you need to either SetAfterSaveBehavior for all of the courses properties to ignore or override the save changes method such that all courses are marked as unchanged before persistent changes into the database. Alright, that's it for the topic of disconnected entities. In the next module, we will take on a big and important subject, value objects.
Mapping Value Objects
Introduction

Hi, my name is Vladimir Khorikov, and this is the course, Domain‑Driven Design and EF Core: Preserving Encapsulation. In this module, we will talk about value objects. We will first discuss single‑property value objects, value objects of that consist of just a single property. And after that, we'll discuss multi‑property value objects.
Introducing a Value Object: Email

If you want to learn more about value objects, check out my Domain‑Drive Design in Practice course and the course about functional programming in C#. But in short, a value object is a concept that doesn't have its own identity. In terms of implementation, a value object is just a class. Two instances of the same value object class are fungible as long as their contents match, meaning you can replace one instance with another of the same content. Value object instances are also immutable. The main reason why you would want to introduce value objects in your domain model is because value objects are immutable and interchangeable, and therefore much easier to work with compared to entities. Immutability is a particularly big benefit here because it helps with encapsulation. You only need to check a value objects of validity once in the constructor. After that, you can freely pass it around, knowing that it's state cannot possibly be corrupted. So because value objects are easy to work with, it makes sense to move as much business logic as possible to those value objects. In our application, we have several candidates that could be represented as a value object. The most important of which are the student name and the student email. We will start with the email value object first and will talk about student name later in this model. To implement the email value object, we need to introduce a base class first. So I'm adding a new class, ValueObject. Here's its implementation. The main part here is this GetEqualityComponents method that you need to implement in ValueObject sub‑classes. The base class uses that method to conduct equality checks and calculate a hash code. It also contains an implementation of the quality operators. Now, with this base class at hand, we can define the email value object. This is the value of the email itself, inheriting it from the base class and implementing missing members. The only member we need to implement is the GetEqualityComponents method, and the only component here is that valuable property. It's also good idea to have an implicit conversion from email to a string, just for readability purposes. Now to convert the string to the email value object, I'm adding a factory method called Create, and now I actually do need a result class. I won't be able to get away with just a string here. Again, I'm blasting through this code, but you can see a more elaborate explanation of all these concepts, including the value object and the result classes, in my course Functional Programming in C#. So I could add the result class too, but at this point, it's easier to use a library that contains implementation of both the Result class and the ValueObject base class. This library is called C# functional extensions. Installing it. Very good. Now I can import the definition of Result of T. And here's the implementation of the factory method. It does several validations of the string argument, and if any of those validations fail, returns a failure. If everything is fine, it returns a success with a new instance of the email value object. Note that the use of this create method is the only way for the client code to instantiate the email value object, which means there is no way to avoid these validations. All right, now that I have imported the library, I don't need the base value object anymore. The library contains the exact same implementation of it. In fact, I copied this implementation from the library. I leave it here for your reference. As you can see, our code still compiles, even after commenting the value object base class. Our application now takes this class from the library. Now that we have the email value object, we can use it in the student class, like this, and also accept it in the student constructor. This has broken two of our student controller methods that work with student emails. The compiler says that that we cannot use the email string in place of the email value object. Which, by the way, is a great thing, because now we have no choice other than to validate the incoming email string before using it in the domain model. And we also cannot accidentally mistake a student name for a student email anymore. The compiler simply wouldn't allow us to use one in place of the other. You might remember how in the third module I mentioned that in order to maintain proper separation of concerns, that when classes shouldn't work with foreign key ID's, they should only deal with navigation properties. Similarly, domain classes shouldn't deal with primitive types either, only with value objects. Of course, as long as you have those value objects defined. Our controller, which acts as an application services layer, should convert all incoming data into value objects, validate them, and only then pass to the domain model. I'm using the createFactory method to do exactly that. Notice that data conversion is intrinsically connected to data validation. You cannot use an instance of the email value object without creating it first, and this result will contain that value object instance only if all the validations have succeeded. If you try to call a result.value on a failed result, this result.value will throw an exception. There is no way for us to violate domain model encapsulation with this implementation. The EditPersonalInfo method needs of this code too. So I'm copying it here and using the result.value instead of the plain email string. All right, but how to map our student class to this new email value object. EF Core now has a great feature that allows you to map single property value objects, it's called value conversions. To use this feature, we need to go to the students mapping and indicate in the email property that it has a conversion to and from plain strings. These two lambda expressions tell EF Core how to do that conversion. The first expression is for converting from an email to a string, which we can do just by calling emails value property. And the second expression is for the opposite conversion, from a string to an email. Let's test how it works. Let's go to the Program class and change Carl's name back to Carl and his email to Carl2@gmail.com. Running the application, that iteration returns okay, which means it has completed successfully. And if I go to SQL Management Studio and rerun this query, you can see that the email has been successfully changed to Carl2.
Shortcomings of EF Core Value Conversions

In the previous demo, we implemented the Email value object. This value object is a single‑property value object, meaning that it consists of just one value, the underlying email string itself. EF Core has a great feature that allows you to map such single‑property value objects, it's called Value Conversions. Value Conversions help you to keep your domain model clean and separated from primitive types. There are some shortcomings when it comes to the use of Value Conversions though. The first one is related to the use of nulls. If the value in the database is null, then it will not be passed to the factory method. EF Core will instead just set the Value object property to null on its own. Let me demonstrate what I mean by that. First, let's see how EF Core instantiates the Email value object when its value is not null. For that, we'll be using this EditPersonalInfo method. I'll put a breakpoint here and here. Running it, we are about to load the student, and you can see that EF Core has invoked our factory method, just as expected. And if I open the Call Stack, you can see that EF Core invoked Email.Create as part of the repository's GetById method, where it materializes the student. Now let's go to the database, make the Email column nullable, and set Carl's email to null. Running the application again, let me put a breakpoint here too, and after I press F5 the execution goes to that breakpoint, meaning that EF Core didn't invoke the Email.Create factory method. If you look into the Student instance, you can see that EF Core just set that email to null on its own. This behavior in and of itself is fine, there's nothing wrong in skipping the factory method, though still, not skipping this method would have probably been a better choice because you can always implement that skipping yourself if you want to. For example, you could implement a wrapper method on top of the factory method that would return null given a null input string. But regardless, this implementation works fine for most cases. The shortcoming here is not the skipping itself, but the restriction EF Core imposes on the types that participate in Value Conversions, and that is if the Emails column in the database is nullable, the type of this value objects property must be nullable too. In other words, I cannot use a struct here. So if I try to represent this nullable email with a Maybe type like this, that wouldn't work because this Maybe type is a struct. And let me just demonstrate what would happen in this situation. If I go to the DbContext, mark this field as not required, and run the application, EF Core will throw this exception where it says that the Email property cannot be of a non‑nullable type because the underlying database column is nullable. And if I don't indicate this field as not required, EF Core will throw another exception, saying that it received an unexpected null from the database. And by the way, if you wonder where this Maybe type comes from, it's from the same library that provides the result and the base value object classes. Let me change this property back, okay. This issue with the way value converters handle nulls should be fixed in a future version. Here is a GitHub issue to track the progress. Another issue with value converters, or rather, a desirable future enhancement is the ability to map one property to multiple columns. In other words, if you have two fields in a database that you would like to represent as one value object, you cannot do that with value converters. Here is the GitHub issue that tracks the progress for that enhancement. To map a value object to multiple columns, you have to use the old‑fashioned owned entity types, so let's see how this can be done.
Introducing a Multi-property Value Object

To show how to work with owned entity types, we will introduce a new business requirement. Let's say that students must have not just name as a single field in the database, but a full name that consists of the first and last names. This name will be our multi‑property value object. I brought the Email column to be a non‑nullable behind the scenes, and I also added this migration script that renames the Name column in the FirstName and adds a new column called LastName. This column will contain an empty string for all students for now. So, let's run this script on our database. The execution is successful. And you can see that the Student table now has both the first and the last name columns. Let's edit the last names of our students manually. Carl's name will be Carlson, Bob's Bobson, and Alice's Alison. All right, here are all of them in a SQL query result. Now let's add a new value object to represent these two new columns called Name. I'll copy the implementation. It's not that different from the implementation of Email. Let's go through it real quick. As you can see, instead of just a single value, like an email, it has two, first and last names. The constructor here is also private to ensure that the only way to instantiate this value object is through the CreateFactory method. In the Factory method itself, we are doing some basic validations, making sure that the names are not empty and that they are not too long. Finally, in the GetEqualityComponents method, we're telling the base value object class that it needs to take into account both fields when comparing these class's instances. Now we can use this new value object in the Student class, and in the constructor, too. To map this property, we need to go to the DbContext and replace this line here with this OwnsOne method call. Here we are telling EF Core that Student owns the name Property, and we're also specifying what this name value object consists of and also how to map the value object's fields to the database columns. All right, if I run this implementation as is, I will get an exception because I also need to declare a parameterless constructor in the value object. Since we have enabled lazy loading, this constructor should be protected, and just to make their sharper warning go away, I'm calling that parameterless constructor from our main constructor. There are a couple of compilation errors because I have to convert the name string into the value object. I'll do that later. For now, I just want to make sure EF Core can materialize the new version of the Student class. Running the application, and I received an exception here because the Name property in the Student class requires a virtual keyword, and I accidentally put that virtual keyword to their own property. Let me fix it. Running it again, and you can see that Carl's name was successfully loaded into the name ValueObject. Very good. Let's now discuss owned entity types in more detail.
Owned Entity Types Behind the Scenes

Alright, so how owned entity types work behind the scenes. Internally owned types are implemented as regular entities, but with one exception. Their IDs are hidden behind the shadow property and thus don't appear in the main classes. Everything else works mostly the same as for regular entities. This implementation generalizes two use cases: mapping owned entities to the same table as the table of the owner and mapping owned entities to separate tables. In our case, we mapped the Name value object to the same table as its owner, student. But this feature also allows us to map it to a table of its own, like this. This decision to implement owned entities the same way as regular entities might look logical at first. After all, why introduce another mechanism when you already have one that works reasonably well? But its actual implementation entails quite a lot of issues that make it harder to use owned entities as value objects. The Entity Framework team has been fixing those issues throughout the last several releases and made great progress in that regard. But there still are scenarios in which owned entities don't work properly. We will discuss those scenarios, and we will also discuss what was fixed in the recent versions of EF Core. And remember, this course is written with EF Core version 3.1. After that, I'll describe how owned entities could have been implemented differently in order to avoid all those issues. So first thing to notice is that if Core requires us to mark the Name property as virtual, which is not bad in an of itself, but shows you that if Core treats the Name value object the same way as the FavoriteCourse entity, not of the Email value object. Of course, the treatment should be the opposite because both Name and Email are value objects, and the FavoriteCourse is an entity. The first issue with this implementation of owned entities is the SQL EF Core generates. This is how looks the SQL query that selects the student after we introduced the Name value object. As you can see, it's become overcomplicated and unnecessarily so. What happens here is because EF Core has generalized the implementation of owned entities for both use cases, the same table and separate tables use cases, it treats the Name value object as if it resides in a separate table because it's the more generic use case, and you can reduce the use case with the same table to that more generic one, which is exactly what EF Core does here. It joins the student table on itself and takes the Email and the FavoriteCourse from the first student table and the First and LastNames from the second one. Of course, this is completely unnecessary. The same result could be achieved with a much simpler SQL query, like this. By the way, this whole goal to serve two use cases with the same table and with separate tables, this whole goal misses the point of value objects. Even though you can store value objects data in separate tables, I don't recommend that you do that. And it doesn't really matter how many fields these value objects consist of. The best way to process them is alongside the host entity. You don't create a separate table for student emails, do you? Nor should you create one for multi‑property value objects, like student name or address. If you want to learn more about value objects and how they are different from entities, check out my Domain‑Driven Design in Practice course. Before I show you another issue with implementation of owned entities, let me fix the controller. Students' names now consists of the first and the last names. So I need to accept both of these in this controller method. Note that in a real‑world application, you would want to put all these arguments in a DTO instead of accepting them all separately. But I don't want to overcomplicate our sample application, so I'm leaving them as is. Now we need to create a Name value object with this factory method which, as I mentioned earlier, will also validate the first and the last names. Let me rename this result into emailResult. We need to validate the name result and return an error if the name is incorrect and pass it to the student constructor. Very good. And the same should be done in the EditPersonalInfo controller method. It should also accept two names instead of one and validate those names, passing the name and the email. To test this implementation, I need to modify the controller method invocation in the Program class. We'll change Carl's name to Carl 2, and his last name to Carlson 2. Running the application, the controller returned an OK, which means everything went well. And if I go to the SQL Management Studio and rerun this query, you can see that Carl's first and last names were indeed successfully updated. Very good. Now back to the shortcoming I was going to tell you about. The second issue with the implementation of owned entities is that you cannot share them across host entities. You cannot take the name of one student and assign it to another student. That would result in an exception. I know this looks like a contrived example in our use case with the Name value object. After all, why would you want to assign Bob's name to Carl? But that's just our particular use case. In fact, assigning a value object from one entity to another is a quite common scenario. For example, imagine that we had an address value object and needed to move Carl to Bob's room in the student campus. In this case, assigning Bob's address to Carl would make sense. Let me demonstrate this use case in practice. Let's retrieve student with ID 2 from the database. This is Bob. And try to assign Bob's name to Carl and see what happens. Running the application, and you can see the exception EF Core throws. This exception tells you that you cannot change the StudentId property in the name entity because that StudentId is part of the principle key. This is, once again, due to the fact that EF Core represents owned entities as regular entities behind the scenes. The StudentId property is the shadow property in the Name owned entity. This shadow property represents the ID of the name entity and binds to the same column as the ID of the host entity, student. Again, these all could have been avoided if EF Core implemented this functionality differently and didn't try to generalize the implementation of owned entities for two use cases, storing them in the same table as the table of the host entity and in separate tables. You can overcome this issue by adding a Copy method to the name value object, like this. But that's another bend in the separation of concerns between the domain model and the ORM. As you might remember from previous modules, to see how well your domain model is separated from the ORM and the database concerns, you need to imagine how we would design your domain model if you will not have to persist your domain objects to the database. In this imaginary ideal world, we wouldn't have to introduce this Copy method in the Name value object. Just like if we were to copy Bob's email, we wouldn't have to add a Copy method to the Email value object. Value objects are immutable, and you can freely pass around and share their instances. The only reason why we're copying the name instance here is to work around the ORM shortcomings. Alright, let me change everything back. Delete this. Good. And by the way, you might remember from the previous module that assigning Name, Email, and FavoriteCourse through public setters is not the best way to handle this use case at the domain model level. We need to introduce a separate method in the student class instead of relying on those public setters. It will accept these three arguments, copying these lines from the controller, deleting this, and replacing this. Now we can use this method in the controller and remove the old code. It might look unnecessary, but it's a good practice to define each operation upon the main classes explicitly, even if all that operation does is update those domain classes properties. For example, here the EditPersonalInfo method explicitly tells which property in the student class is classified as its personal information. This practice also follows the guideline of always using only one domain model operation per business use case. You can see here that there is only one such operation in the RegisterStudent controller method, and that is the student constructor invocation. The other methods also follow this guideline. Here the only domain model operation we are using is the Disenroll method and here Enroll. There's no reason to violate this guideline in the EditPersonalInfo controller method. Now that we've introduced a separate method for updating the student personal info, I can make all these properties private. And also because all three of the personal info properties are mandatory, we need to put preconditions in this method as well. These preconditions will throw an exception should we pass null to any of these arguments. Note that in a real‑world project, you would probably want to have a helper class where you could put such preconditions just to make them less verbose, like you can see here. But for our simple project, these three if statements are good enough.
Recap: Owned Entity Types Behind the Scenes

In the previous clip, we discussed how owned entity types work behind the scenes. Owned types are implemented as regular entities, where their ID is hidden behind the shadow property. This implementation generalizes the two use cases, mapping owned entities to the same table as the table of the host entity, and mapping owned entities to a separate table. Such a generalization makes it harder to use owned entities as genuine value objects. Besides, it is completely unnecessary in scenarios with value objects because the only legitimate way to store them in the database is in the same table as the host entity. We discussed two issues with the implementation of owned entities. First, EF Core generates over‑complicated and less‑optimized SQL queries, where it unnecessarily joins the host entity on itself. And second, you cannot share an instance of an owned entity between different host entities. Both of these issues are consequences of trying to accommodate the two persistent use cases. There were other issues in earlier versions of EF Core, but thankfully those issues were fixed in version 3.1. For example, you couldn't set the student's name property to null and had to resort to the null object design pattern. For instance, if the first and last names are both nullable in the database, you would naturally want to make the name value object nullable in the student class too, but you couldn't do that because EF Core required the student class to always have a non‑null reference to the owned entity. So instead of assigning null, you had to assign an empty name object. For that, you would need to make the first and last names nullable in the name value object itself, which of course could have been a huge breach in encapsulation if by your application's requirements, both fields in the name value object are mandatory. Now this is fixed, and if both first and last names are nulls in the database, EF Core will assign null to the name property in the student class. It will only assign this property a non‑null reference if at least one of the database fields is not null. There also were issues with replacing instances of owned entities with new instances, but they were fixed, too. Alright, I mentioned earlier that we will discuss how owned entities could have been implemented differently to avoid all these issues in the first place, and that is by dropping the support for the separate tables use case, removing the owned entity ID shadow property and attributing all changes in the owned entity to the host entity. As I said, there is no practical need for mapping owned entities to separate tables. All this support does is it over‑complicates the implementation and makes it harder to adopt owned entities for the value object's use case. If you worked within Hibernate, you might remember the feature called Component. Here is a sample mapping from my Domain‑Driven Design In Practice course. This feature works exactly as I described. It gathers several columns from the database table into a single class, Component, without introducing a separate ID. All changes in these fields are attributed to the host entity, not to the component itself. This makes this feature a perfect fit for the value object use case. In my opinion, EF Core would benefit greatly from the same functionality, either by repurposing the owned entities feature or introducing a new one that would mimic the behavior of components in Hibernate.
Adding a Navigation Property to an Owned Entity

The last thing I would like to show you with regards to value objects and owned entities is how to add a navigation property to a value object with EF Core. There are quite a few scenarios where this might be useful, so let's see how this can be done. So let's say that our students, in addition to their first and last names, might also have a name suffix such as junior or senior. The list of possible suffixes will be another enumeration entity with a separate table in the data base. I already created the migration script to add that table and a new column to the student table. Let's run it on our database. The script also adds data to this table. Let me refresh the list of tables, and here it is, the suffix table with two suffixes inside, junior and senior. And you can also see the new column in the student table. All right, as I said, that would be a new enumeration entity, for which we need a new class. And I'm copying the content of that class here. Structure wise, it's pretty much the same as the Course class. It also has all possible values listed here explicitly, which are junior and senior. And, of course, we don't need a setter here. The suffix is part of the student's name, so it's natural to put a reference to the suffix in the name value object. I also need to accept it in the constructor and assign the value to the property. The factory method should accept it too, and pass to the constructor. Now we need full validation because the only type of validation that can be done here is checking for null. And we don't need that because the name suffix is not a mandatory field. And, of course, it should also participate in the quality comparison. So I'm adding this field here too. In the controller, I'm introducing a new argument which we will convert into a suffix instance similar to the course enumeration. And pass the result to the factory method. Note that because the suffix is not a mandatory field, technically, we need to make this argument nullable and be able to handle this case property. I'm omitting this use case for brevity. We'll just make the SuffixId mandatory at the controller level. We need to do the same in the EditPersonalInfo, copying the conversion code from here, and passing the suffix to the Factory method. At this point, all this is pretty much standard, and we already did it with the student and the favorite course. Where you may see difficulties is in the mapping between the value object and its navigation property. The mapping of the suffix itself is the same as for the course class. But if you try to add the navigation property to the name owned entity like this, it wouldn't work. Let me demonstrate it to you really quick. I need to add a new parameter to our test code and run the application. You can see that it doesn't work because, by default, if Core tries to map to this column name, which is the combination off the name of the parent entity and the SuffixId, divided by an underscore. In our database, though, this column doesn't contain the underscore. So we need to tell Entity Framework the correct column name. And this is where it might be tricky if you never did that before. You cannot just specify the column here with a HasColumnName method. You need to declare a shadow property first, map it to the column name, and then map the navigation property to that shadow property, which, consequently will map the navigation property to the proper column. Notice that because of the suffix is not mandatory, I'm marking it as not required. Also noticed that I have declared that the shadow property with a nullable long type, not just long. That's also because the suffix is nullable in the database. Let's run our application, and you can see that it works now. The suffix shows a null because there is no suffix in the database yet. Another issue with this implementation is that just like with a course enumeration class, the name suffix also gets updated every time we attach it to the student aggregate. To fix this issue, we need to mark all suffix instances as unchanged before saving them to the database. We could do that the same way we did here with the SetAfterSaveBehavior method. But modifying the SaveChanges method would be simpler and more straightforward, at least when you start to have more than one enumeration class. So I'm removing this line. Also because these two for each loops are almost exactly the same, it's a good idea to reuse these logic. So let's create a new constant in our DBContext and call it EnumerationTypes. This array will contain all the classes in our demo model that implement the enumeration pattern. If we were to add another such class, we can add it to this array later. So this is how we can find all enumerations being tracked by the DBContext and mark them as unchanged. Let me remove this. Very good. Let's test these changes. Running the application the result is okay. Good. And if we go to the SQL Profiler, we will see the two select statements, one for the student and the other one for his enrollment. And we will also see the update query that changes Carl's name suffix. But we will not see updates of the course or the suffix records, which is exactly what we need.
Summary

In this module, we discussed value objects and how to map them with EF Core. There are two types of value objects in terms of their support in Entity Framework, single‑property and multi‑property. We've introduced a single‑property value object, Email. EF Core has a great feature that helps you map such value objects. This feature is called value conversions. It is especially good because it allows you to keep the domain model clean and separated from primitive types. In our case, the student class only contains the property of type Email. EF Core deals with the underlying string, such that that string is not present in the domain model. There is one downside in the current implementation of value conversions though, and that is the restriction EF Core imposes on the types that participate in value conversions. If the corresponding column in the database is nullable, the type of the value objects property must be nullable too, which means we cannot represent the nullable property with a maybe type, because that type is a struct, and thus is not nullable. We have also introduced a multi‑property value object, student's name, to map it, we used the EF Core feature called owned entity types. Owned entity types implementation generalizes to use cases, mapping owned entities to the same table as the table of the owner, and mapping owned entities to separate tables. While it might look like a good idea at first, this generalization puts restrictions on owned entity types, which make it harder to use them as genuine value objects. The EF Core team has fixed a lot of issues that were a consequence of that implementation, but there still are a few, namely, EF Core generates an insufficient SQL query, and it also doesn't allow you to share the same value object instance between two host entities. It would be best to drop the support of the separate tables use case, remove the owned entity ID shadow property, and attribute all changes in the owned entity to the host entity. These changes will make the owned entities a perfect fit for value objects. Finally, we discussed how to add a navigational property to a multi‑property value object. It's a quite common use case in domain‑driven design, and it's useful to know how to implement this with EF Core. In the next module, we will talk about domain events, as well as one‑to‑one and one‑to‑many relationships.
Implementing a Domain Event Dispatcher
Introduction

Hi, my name is Vladimir Khorikov, and this is the course Domain Driven Design and EF Core: Preserving Encapsulation. In this module, we will talk about dispatching domain events. We will also talk about one‑to‑one and many‑to‑many relationships.
Domain Events

Before implementing a dispatcher, let's first discuss what domain events are and in what scenarios they are useful. You can find additional discussion of domain events in my Domain Driven Design in Practice course. Domain events represent domain‑specific changes in your system. What differentiates domain events from regular events is the fact that domain events have domain meaning. An example of a regular event is a ButtonClick. An example of of domain event would be something like a student EmailChangedEvent. For instance, let's say that there is another application in our university that notifies students about public events. That system has to maintain an up‑to‑date least of student emails in order to send email notifications. And so, whenever a student changes their email address, our application could raise an EmailChangedEvent. This event will then get dispatched to message bus, and if the external application is subscribed to that message bus, it will get this event and update its records as necessary. The use of domain events is a good way to implement a publisher‑subscriber mechanism between applications. There are two separate mechanisms at play when it comes to domain events, raising an event and dispatching an event, and it's important not conflate the two. Raising an event is part of the decision‑making process, and it is a responsibility of the domain model itself to decide when to raise an event. On the other hand, dispatching an event is a purely technical process. This responsibility is part of the application services layer. Let's take our example with updating a student's email and put it into the broader picture. This is our application represented as an onion, or a hexagon. It consists of two layers, the domain layer, which you can see in the middle, and the application services layer that sits on top of the domain layer. Everything outside of these two layers is external world, the end user, a message bus, third‑party systems, and so on. Let's take the EditPersonalInfo use case that we implemented in the previous modules, and let's also assume that our application is an API system. When an external application calls our API, it sends a set of data defined in our API specification. We render that data into a data transfer object, DTO for short. That DTO serves us as a data contract. It is the responsibility of the application services layer to accept and materialize data from client applications and also handle communication with all such external applications. In our case, the student controller does exactly that. The only difference is that I didn't introduce DTO classes for simplicity's sake. But you can assume that the primitive types our controller accepts are part of the in‑common DTO. The other responsibility of the application services is layer is to coordinate the work between the domain model and external applications, or as I like to call them, out‑of‑process dependencies. This is what the student controller does next. It converts all the data it received from the external application into domain objects and then delegates the work to those domain objects. And keep in mind that the act of data conversion is intrinsically linked to data validation. If it at any step during that conversion the controller encounters an invalid piece of data, it returns an error. In our particular use case, we converted the studentId into a student entity, and the email string into an email value object. The next step is to delegate the decision‑making process to the domain model. This is the call the controller makes to the student's EditPersonalInfo method. During that call, the student updates its email and then may decide to raise a domain event regarding the updated email. The student does that by adding that event to an internal collection of domain events. When the student is done with its decision making process, the controller examines the results of that decision and starts to act on it. It communicates the changes back to external applications, saves the student to the database, and dispatches all domain events. The dispatching process itself consists of converting a domain event back to a DTO and sending that DTO to a message bus. Notice the symmetry here. The DTOs, the data contracts, reside on both sides of the communication process. Our application accepts those DTOs from the external world, parses them into domain objects, and then serializes all the domain events back to DTOs and sends them to the external world. Notice also the similarity between persisting the student to the database and dispatching of domain events. Both of these actions are how the controller acts on the decisions made by the domain layer. All right, let's now implement all this in our application.
Implementing Domain Events

I'm creating a new file that will contain all classes related to domain events. First of all, we will need an IDomainEvent interface. This is an empty marker interface. The only responsibility off this interface is to flag all the main event classes in our application. We will have one such class, StudentEmailChangedEvent. Notice a couple of things here. First is, of course, that this class derives from the marker interface. And second, it contains the students ID and the students new email, and that the new email is represented with a value object. The common question, which often pops up when it comes to domain events is should they only consist of primitive types or can they also contain the main classes? And the answer is domain events can contain value objects, but not entities. Remember that domain events are part of the domain layer, and so it's perfectly fine for them to refer to other domain classes. But domain events should also be mutable because they represent effect, something that already took place and cannot be changed afterwards. And so, although domain events can refer to other domain classes, they can only refer to those domain classes that themselves are immutable. Students are entities and therefore are not immutable, but the email is a value object, and so it's fine to include it as is into the event. Alright, now that we've defined the domain events themselves, we can introduce the functionality for raising them. As I mentioned previously, raising a domain event is the responsibility of the domain classes themselves, and boils down to just creating an event and placing it into a collection of all events in the entity. This is that collection. And this is the method that will raise an event. Note that that this method is protected. This is because only entities themselves may raise those events. This method shouldn't be accessible to other classes. Also note that technically raising an event is a responsibility of an aggregate root, not an entity, and in my Domain‑Driven Design in Practice course, I also defined a separate abstract class called AggregateRoot, derived from entity, and I put this functionality to that class. The separate AggregateRoot class helps differentiate between entities internal to an aggregate and AggregateRoots. I don't use that class much in production code bases though, because usually it's quite easy to differentiate between internal entities and AggregateRoots. But both approaches are fine. If you like to define the AggregateRoot class, then move all this code there. Otherwise, you can keep it in the entity base class. The EmailChangedEvent should be raised in the EditPersonalInfo method, when the new email is different from the old one. Now that the event is raised, we need to think about dispatching it. Remember, I mentioned earlier the similarity between saving changes to the database and dispatching of domain events. Both of these actions is how the controller converts in the decisions made by the domain layer into side effects. The domain layer has made all the decisions here in this method, and this method call is where the controller persists the results of those decisions. We could dispatch domain events right after this call, but it's a good idea to leverage the RM for the scenario because the RM already has a list off all entities modified during this business transaction, and we can easily retrieve those entities and dispatch their events. So let's go to the SaveChanges method and get the list of entities tracked by the DBContext. I am saving the result of the call to the base class in a variable. And now, for each entity we need to dispatch its events and clear those events afterwards. And finally, after all that is done, we can return the result we received from the base class. Now to clear all domain events in an entity, we need another method in that entity that would clear the internal collection. Again, don't expose of the collection itself. That would be a breach in encapsulation, instead expose operations upon that collection using separate methods. Calling this method here, as far as event dispatching, will need some additional infrastructure. I'll put it here, along with the domain class itself. Let me just make this class sealed real quick. Good. So for the infrastructure, we need the class and that would be responsible for putting messages on the Bus. I am defining an interface for that class and the class itself. Of course, for our sample application, we will not be sending real messages, just try them in our console. In addition to the Bus class, we will also have another one, MessageBus. This class will work on top of the Bus, and that's why it accepts it in the constructor. And it will be responsible for composing messages that our application sends out to external systems. In our case, we have just one such message that the student email has changed. Of course, in the real world application, this text would most likely be a JSON, but for our purposes, this comma separated string is good enough. At this point, you might ask, why do we need two classes, Bus and MessageBus, and not just one? It is possible to merge the two classes together, but that would be a sub optimal solution. These classes have different responsibilities. Bus is a wrapper on top of the MessageBus as the key library that is provided by the company that develops that MessageBus. This wrapper encapsulates nonessential technical details, such as, for example, connection credentials, and it exposes a nice and clean interface for sending arbitrary text messages to the Bus. Of course, you don't see all those technical details here because we don't actually use a MessageBus. But in the real world application, you would have some configuration parameters injected into the Bus's constructor, and also some Bus initialization logic. On the other hand, a MessageBus defines messages specific to our domain. This class helps you keep all such messages in one place and reuse them across its application. As you can see, these two responsibilities, hiding the external libraries complexity and holding all application messages in one place, they are complimentary but still different. And so it's better to keep them separated. Next, we will have the EventDispatcher itself. It will work on top of the MessageBus and will have a Dispatch method that will take a list of domain events and dispatch them one by one. Here's how the dispatching will look. We will have a switch statement, and if the event is a StudentEmailChangedEvent, we will call the MessageBus with the data from that event. And if in the future we will need to add more domain events, they may go here as separate case statements. And to catch all unhandled domain events, I am putting this default statement here that will throw an exception. Again, same question here, why not merge this EventDispatcher with the MessageBus class? It's because calling a MessageBus is not the only possible reaction to a domain event. We may need to process some of the domain events differently. For example, if that's a domain event related to system audit, we may need to write it down to a special file. In this case, we would need to inject a logger into this EventDispatcher and use that logger for those ordered events. Think of the EventDispatcher as something that converts domain events into side effects. In our particular case, those side effects are messages on the Bus, but they could be anything, including new lines in a log file, for example. All right, now that we have all that infrastructure in place, we can inject the EventDispatcher into our DBContext, save it to a private field, define the field itself, and now use that field to dispatch all events in the entity. Our application doesn't compile anymore. And that's because we need to supply the EventDispatcher when instantiating this cool context. And to do that, we need to first define the Bus, then instantiate a MessageBus, use that MessageBus instance to create the EventDispatcher, and finally pass that dispatcher to the DBContext. Let's modify Carl's email to Carl1 and run the application. The result is okay, good. And if we look at the console window, we can see that the message was successfully raised and dispatched. Very good.
Recap: Implementing Domain Events

In the previous demo, you saw the implementation of domain events. Let's recap what we did there and why. We've introduced the StudentEmailChangedEvent, and we also implemented two different aspects related to domain events, raising an event and dispatching it. Raising an event is the responsibility of the domain model. For that, we added a collection of domain events, as well as methods for working with that collection to the base entity class. Note that raising an event is a responsibility of aggregate roots, not just any entity. We could define an explicit aggregate root class and put all this functionality there. But in my experience, not having that explicit class is usually fine too. Just take into account aggregate boundaries when raising a new event. Such events should only be raised by aggregate roots, not internal entities. In our example, only the student class may raise events. The enrollments, which are entities internal to the student aggregate, cannot raise those events. We have also implemented dispatching of domain events. This is a responsibility of the application services layer. And we have leveraged our DbContext to do that. The reason why is because EF Core already has the list of entities affected by the current business transaction. And all we need to do is iterate through that list and dispatch the events of each entity. We've added three new classes for event dispatching, the EventDispatcher itself, MessageBus, and Bus. The Bus class is a wrapper on top of the MessageBus SDK library that is provided by the company that develops that MessageBus application. This wrapper encapsulates non‑essential technical details, such as, for example, connection credentials. The MessageBus class contains all messages specific to our domain. Finally, the EventDispatcher converts domain events to calls to the MessageBus. Note that the Bus class has a corresponding interface, but MessageBus and EventDispatcher do not. This is related to marketing best practices. It's outside the scope of this course. But in short, you want to verify interactions with external applications at the very edges of your system in order to maximize protection against bugs. Bus resides at that edge. It's the very last class in the chain of classes between the controller and the external application, while the MessageBus class and the EventDispatcher are only intermediate steps on that way. You can read more about it in my recently published book, Unit Testing Principles, Practices, and Patterns. Alright and the last note here. We used the domain event to communicate with external systems, specifically to notify those external systems about changes in student emails. This is the so‑called inter‑application communication, meaning communication between applications. You may also sometimes see people using domain events for intra‑application communication, meaning for communication where consumers of the domain events reside within the same application. I don't recommend that you do that. Domain events used for intra‑application communication don't add much value. At the same time, they complicate the code. If all the collaborating parties reside in the same domain model, it's better to make the flow of domain logic explicit and avoid dealing with domain events. Domain events bring significant complexity overhead in the form of indirection. It's best to avoid this overhead whenever you can.
Many-to-many Relationships

Let's talk about many‑to‑many relationships. Here is an example of it. A student has many instructors and each instructor also has many students. As I mentioned earlier, a many‑to‑many relationship can be represented with two one‑to‑many relationships. In this case, the intermediate table becomes an entity in your domain model. Each student and instructor will have a collection of those entities instead of collections of each other. Pure many‑to‑many relationships, relationships where the intermediate table contains only the composite key, are pretty rare. More often than not, a many‑to‑many relationship will contain some additional information. For example, in our database, we can look at the enrollments table as an intermediate table between students and courses, and we can also deem the relationship between students and courses as many‑to‑many. But when the intermediate table contains some additional data, it usually makes sense to elevate it into an entity of its own, like we did with the Enrollment class. Unfortunately, EF Core doesn't support pure many‑to‑many relationships. In order to map of this database structure, you will have to introduce this intermediate table as an entity to your domain model. This, of course, is another dent in separation of concerns, because you wouldn't elevate this table into an entity if it wasn't for the shortcomings of the ORM. If you have to do that, if you have to introduce this intermediate table as an entity, my recommendation is to treat it as a fully fledged internal entity. Give it a readable name. For example, here, instead of student to instructor, you can name this entity InstructorEnrollment, or something similar. Also give this table its own dedicated primary key. It's generally not a good idea for fully fledged entities to have composite keys because they are harder to work with. So in this example, you can refactor the intermediate table into this one. Note the unique index in the StudentID and InstructorID columns. It provides that the same uniqueness guarantees, but without having to have a composite primary key.
One-to-one Relationships

Here is an example of a one‑to‑one relationship I brought up in the earlier modules. In this relationship, each student row has one corresponding row in the StudentDetails table. And also, each StudentDetails has only one Student. At the database level, you can create a one‑to‑one relationship by creating a foreign key constraint from StudentDetailsID to StudentID. At the domain level, one‑to‑one relationships are represented with a reference to the related entity. As you might probably noticed, this type of relationship is very similar to value objects. And indeed, for all practical purposes, one‑to‑one relationships behave exactly the same way as value objects. But as I mentioned in the previous module, value objects are easier to work with than entities. And so I recommend that you always choose value objects over one‑to‑one relationships and not only that, but value objects that reside in the same table as the host entity in the database. The only exception to this guideline is when this table contains large amounts of data, such as image blobs or files. In this case, loading this data every time you load the main entity may affect performance. And so it's reasonable to put it into a separate table, which is related to the main table as one‑to‑one. But again, in all other cases, prefer value objects over one‑to‑one relationships.
Resource List

Here are useful links that I referred to in this course. The source code for this course is available on GitHub. By the time this course goes live, this repository will contain code from all modules. You can navigate through these modules by exploring the commit history. I'll organize all commits such that you will be able to roll back changes to the start of the specific module. Just look for tags named after modules in the source control. If you need an introductory course on the topic of domain‑driven design, I recommend my DDD in Practice one. Here are the GitHub issues I referred to in this course. This one is about the way value converters handle nulls. This one is about using value converters to map one property to multiple columns. This one is the discussion about many‑to‑many relationships, and this one is about implementing them. Finally, this is my recently published book, Unit Testing Principles, Practices, and Patterns. I intended it as a complete guide to unit testing
Course Summary

We have made great progress in this course. You have learned about encapsulation and separation of concerns, and how to use EF Core to preserve these properties of your domain model. We discussed many‑to‑one relationships, and how navigation properties should be preferred over foreign key IDs in the domain model. We also discussed how lazy loading helps you keep your domain model simple while maintaining a good level of performance in the application. Next, we talked about one‑to‑many relationships, and the drawbacks in EF Core's lazy loading implementation. We also talked about working with the connected or detached objects, and mapping value objects. Finally, we implemented a domain event dispatcher. Be sure to subscribe to my blog, where I will be posting announcements about future courses. This is the short link for you to do that. Also, here are my Twitter handle and blog. This is Vladimir Khorikov, thank you for listening.

<https://github.com/vkhorikov/DddAndEFCore>